:toc:
:toc-placement!:

toc::[]

[IMPORTANT]
.This is a work in progress
----
Until I get this all working, the text/code snippets below are imaginary only. This will end up in the multirepository scenario as something like this:

* Create a fork of the ecosystem repo called the governancezone repo
* Update the governancezone repo using the main branch of the ecosystem repo
* Check the governancezone repo out locally and make edits
* Commit the changes to the governancezone repo
* Push the changes to the governancezone repo
* Using github, Create a pull request from the fork branch to the main branch of the ecosystem repo

It will be similar for making team model updates just replacing governancezone repo with team repo in the above.
----

This folder contains examples of code to bootstrap a catalog using either multiple repositories responsible for different parts of the model or use a single repository which can modify the whole model. The single repo may be fine for development but for production it is recommended to use multiple repositories as different teams will want control on who can change different parts of the model.

== Single Repository
This is the simplest use case. Here, we imagine a single GIT repository that will host the catalog. The catalog consists of a number of authorizable elements:

* Ecosystem
This is the top level element. It manages GovernanceZones. All GovernanceZones must be declared at the Ecosystem level before being used/defined.
* GoveranceZones
GovernanceZones manage a set of StoragePolicies, DataPlatforms and Teams. Teams must be declared at the GovernanceZone level before being used/defined. Storage Policies and Platforms can be changed using the GovernanceZone repository. Teams have an associated Repository when they are create using a TeamDeclaration. All objects managed by a given team are controlled by the associated repository.
* Teams
Teams are used to manage Datastore and their associated Datasets as well as Workspaces. The repository associated with a team is the only source for changes to objects under that team.

Here, we use a single file which contains a simple Ecosystem which declares a single GovernanceZone. The GovernanceZone has a single Team which defines a single Datastore with 2 Datasets. The Ecosystem, GovernanceZone and Team all use the same GitRepository as their source of truth. Thus any changes can be done from a single GIT repository.

[source, shell]
----
cd ecofolder
git init
Edit the eco.py file
git add .
git commit -m "Define whole model in one commit"
git remote add origin ecosystem_repo_url
git push -u origin main
----


== Multiple Repositories
We will define the same Ecosystem as the single repository case. The only difference is that the Ecosystem, GovernanceZone and Team each have their own GIT Repository. This allows different teams to manage different parts of the model. Each GIT repository would be configured with different people and possibly processes to manage changes to that repository.

We will need to create the model in 3 steps because of the multiple repositories.

=== Step 1, Create the ecosystem and declare the GovernanceZone
The multi_repo/Step1/eco.py is the first file to check in to the ecosystem gitrepository. The ecosystem use the ecosystem repo and the GovernanceZone is declared to use its GIT repo. Only the ecosystem repo can add or remove governancezones. Once, this is commited to the ecosystem repo then we can proceed to the next step, defining the GovernanceZone.

[source, shell]
----
cd ecofolder
git init
Edit the eco.py file
git add .
git commit -m "Initial commit"
git remote add origin ecosystem_repo_url
git push -u origin main
----

=== Step 2, Define the GovernanceZone
Once the GovernanceZone has been declared by the ecosystem repository, then we can define the GovernanceZone using changes source from the GovernanceZone repository. The multi_repo/Step2/eco.py file contains the eco.py with the GovernanceZone defined. Note, the authorization system is not file based, its object based. Any repository can change any file BUT, changes will only be accepted so long as the model is valid, backwards compatible AND the elements in the model which changed came from a repo authorized to change those elements.

The newly defined GovernanceZone also declares the Team and specifies the repository the group managing that Team will use for making changes to the Team in the model.

First setup a local folder to connect to the governancezone repo.

[source, shell]
----
cd governancezonefolder
git clone ecosystem_repo_url
git checkout -b main
git remote add govRepo governancezone_repo_url
git pull govRepo main
Edit eco.py to include the governance zone definitions.
git add .
git commit -m "Added governance zone"
git push origin main
----

Clearly, the above commands are for the first time. Once the repository is setup then the governance team would just do a git pull, make the changes and so on.

=== Step 3, Define the Team, Datastore and Datasets
Now, that the Team is declared. The team can be defined by pushing code from the Team git repo to the ecosystem repo.

[source, shell]
----
cd teamFolder
git clone ecosystem_repo_url
git checkout -b main
git remote add teamRepo team_repo_url
git pull teamRepo main
Edit eco.py to include the team definitions.
git add .
git commit -m "Added Team and its datastores and datasets"
git push origin main
----
Clearly, the above commands are for the first time. Once the repository is setup then the team "team" would just do a git pull, make the changes and so on.

=== Conclusion
At this point, the team managing the ecosystem can modify the model directly so long as they only modify the ecosystem elements. Elements below that associated with a different repository cannot be modified by the ecosystem repo. The same is true for the governancezone repo. It can modify the governancezone and below but not the ecosystem. The team repo can modify the team and below but not the governancezone or ecosystem.

This federates control and allows each team to manage their subsets of the model without interference.

