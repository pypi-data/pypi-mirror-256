// ==================================================
// RTL generated by RapidStream
//
// Copyright 2024 RapidStream Design Automation, Inc.
// All Rights Reserved.
// ==================================================
`timescale 1 ns / 1 ps

module __rs_hs_pipeline_body #(
    parameter DATA_WIDTH = 32,
    parameter LEVEL      = 2
) (
    (* RS_CLK *)  input wire clk,
    (* RS_RST *)  input wire reset,

    // inbound
    (* RS_HS = "inbound.ready" *)  output wire                  if_full_n,
    (* RS_HS = "inbound.valid" *)  input  wire                  if_write,
    (* RS_HS = "inbound.data"  *)  input  wire [DATA_WIDTH-1:0] if_din,

    // outbound
    (* RS_HS = "outbound.valid" *)  output wire                  if_empty_n,
    (* RS_HS = "outbound.ready" *)  input  wire                  if_read,
    (* RS_HS = "outbound.data"  *)  output wire [DATA_WIDTH-1:0] if_dout
);

  wire                  full_n  [LEVEL:0];
  wire                  empty_n [LEVEL:0];
  wire [DATA_WIDTH-1:0] data    [LEVEL:0];

  genvar i;
  generate
    for (i = 0; i < LEVEL; i = i + 1) begin : inst
        __rs_fifo_reg #(
          .DATA_WIDTH(DATA_WIDTH)
        ) unit (
          .clk(clk),
          .reset(reset),

          // connect to fifo[i+1]
          .if_empty_n(empty_n[i+1]),
          .if_read   (full_n[i+1]),
          .if_dout   (data[i+1]),

          // connect to fifo[i-1]
          .if_full_n  (full_n[i]),
          .if_write   (empty_n[i]),
          .if_din     (data[i])
        );
    end

    // write
    // must not write if full_n is 0
    assign if_full_n  = full_n[0];  // output
    assign empty_n[0] = if_write;   // The guarding logic is put in the head module
    assign data[0]    = if_din;     // input

    // read
    assign if_empty_n    = empty_n[LEVEL];  // output
    assign full_n[LEVEL] = if_read;         // input
    assign if_dout       = data[LEVEL];     // output

  endgenerate

endmodule   // __rs_relay_station



module __rs_fifo_reg #(
  parameter DATA_WIDTH = 32
) (
  input wire clk,
  input wire reset,

  // write
  (* keep = "true" *)
  output reg                   if_full_n,
  input  wire                  if_write,
  input  wire [DATA_WIDTH-1:0] if_din,

  // read
  (* keep = "true" *)
  output reg                   if_empty_n,
  input  wire                  if_read,
  (* keep = "true" *)
  output reg  [DATA_WIDTH-1:0] if_dout
);

  always @ (posedge clk) begin
    if_dout <= if_din;
    if_empty_n <= if_write;
    if_full_n <= if_read;
  end

endmodule
