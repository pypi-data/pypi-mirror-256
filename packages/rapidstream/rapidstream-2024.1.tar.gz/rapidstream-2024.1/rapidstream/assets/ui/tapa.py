"""RapidStream UI for TAPA projects."""

__copyright__ = """
Copyright 2024 RapidStream Design Automation, Inc.
All Rights Reserved.
"""

import concurrent.futures
import logging
import subprocess
import xml.etree.ElementTree as ET
import zipfile
from pathlib import Path
from typing import Any

import jinja2

from rapidstream.assets import PACKAGE_XO_TCL, VPP_TEMPLATE
from rapidstream.assets.cluster.tasks.vivado import run_vivado
from rapidstream.assets.cluster.util import check_async_command
from rapidstream.assets.ui.common.impl import paramterized_export_project
from rapidstream.assets.ui.common.structure import (
    EXPORTED_DESIGN_PATH,
    EXPORTED_IMPL_PATH,
    EXPORTED_PATH,
    EXPORTER_XDC_FLOORPLAN_PATH,
    GENERATED_PACKAGE_XO_DIR,
    GENERATED_XO_DIR,
)
from rapidstream.assets.ui.hls import RapidStreamHLS

_logger = logging.getLogger(__name__)


def parameterized_export_xo_file(
    kernel_xml_path: Path,
    component_xml_path: Path,
    top_module_name: str,
    hdl_dir: Path,
    package_xo_dir: Path,
    output_xo_file: Path,
) -> None:
    """Export the project as an XO file."""
    _logger.info(f"Exporting XO file {output_xo_file} based on:")
    _logger.info(f"  kernel_xml: {kernel_xml_path}")
    _logger.info(f"  component_xml: {component_xml_path}")
    _logger.info(f"  top_module_name: {top_module_name}")
    _logger.info(f"  hdl_dir and subfiles: {hdl_dir}")

    assert kernel_xml_path.is_file()
    assert component_xml_path.is_file()
    assert hdl_dir.is_dir()
    assert package_xo_dir.is_dir()

    # Parse `component.xml` to retrieve the list of bus interfaces.
    # extracted_xo_dir = self.work_dir / GENERATED_XO_DIR
    # component_xml_path = extracted_xo_dir / self.xo_ip_relpath / "component.xml"
    component_xml_tree = ET.parse(component_xml_path)
    ns = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"
    ifaces = {}
    for iface in component_xml_tree.getroot().findall(
        f"./{{{ns}}}busInterfaces/{{{ns}}}busInterface",
    ):
        iface_name = iface.find(f"{{{ns}}}name")
        bus_type = iface.find(f"{{{ns}}}busType")
        assert iface_name is not None
        assert bus_type is not None
        library = bus_type.get(f"{{{ns}}}library")
        if library == "interface":
            params = {}
            for param in iface.findall(f"./{{{ns}}}parameters/{{{ns}}}parameter"):
                param_name = param.find(f"{{{ns}}}name")
                param_value = param.find(f"{{{ns}}}value")
                assert param_name is not None
                assert param_value is not None
                assert isinstance(param_name.text, str)
                assert isinstance(param_value.text, str)
                params[param_name.text] = param_value.text
            assert isinstance(iface_name.text, str)
            ifaces[iface_name.text] = params
        else:
            assert library == "signal"
    _logger.debug("Found bus interfaces: %s", ifaces)

    # Generate TCL script to create the output XO file.
    # package_xo_dir = self.work_dir / GENERATED_PACKAGE_XO_DIR
    # package_xo_dir.mkdir(parents=True, exist_ok=True)
    assert top_module_name is not None
    # kernel_xml_path = extracted_xo_dir / self.top_module_name / "kernel.xml"
    tcl = package_xo_dir / "package_xo.tcl"
    tcl.write_text(
        jinja2.Template(Path(PACKAGE_XO_TCL).read_text(encoding="utf-8")).render(
            xo_file=output_xo_file,
            top_name=top_module_name,
            kernel_xml=kernel_xml_path,
            hdl_dir=hdl_dir,
            work_dir=package_xo_dir,
            ifaces=ifaces,
        ),
        encoding="utf-8",
    )
    _logger.info("Exporting XO file `%s`", output_xo_file)
    check_async_command(run_vivado.submit(tcl, cwd=package_xo_dir))


class RapidStreamTAPA(RapidStreamHLS):
    """The TAPA flow of RapidStream.

    This class is used to run the RapidStream flow for TAPA projects.

    Attributes:
        xo_file: Input XO file generated by TAPA.
        xo_ip_relpath: Relative path of the IP directory in `xo_file`.
    """

    xo_file: Path
    xo_ip_relpath: Path
    connectivity_ini: Path
    vitis_platform: str

    def set_vitis_platform(self, vitis_platform: str) -> None:
        """Set the Vitis platform name."""
        self.vitis_platform = vitis_platform

    def set_vitis_connectivity_config(self, connectivity_ini: Path) -> None:
        """Set Vitis connectivity configuration file.

        This function will add the Vitis connectivity configuration file to the project.

        TODO: setup port to region for known board.
        """
        assert not hasattr(
            self, "connectivity_ini"
        ), f"Already added connectivity configuration file `{self.connectivity_ini}`"
        self.connectivity_ini = connectivity_ini

    def add_xo_file(self, xo_file: Path) -> None:
        """Add XO file generated by TAPA.

        This function will add RTL source files (including XCI files) and HLS report
        files from `xo_file`, and set the top-level module name and the part number
        based on the metadata from `xo_file`.

        This function should be called once and only once for each project.
        """
        # Remember the path of the input xo file for exporting.
        assert not hasattr(self, "xo_file"), f"Already added xo file `{self.xo_file}`"
        self.xo_file = xo_file

        # Extract the xo file to the work directory.
        extracted_xo_dir = self.work_dir / GENERATED_XO_DIR
        extracted_xo_dir.mkdir(parents=True, exist_ok=True)
        with zipfile.ZipFile(xo_file, "r") as xo_fp:
            xo_fp.extractall(extracted_xo_dir)

        # Parse `xo.xml` to get RTL source directory path, HLS report directory path,
        # and top-level module name.
        xo_xml_tree = ET.parse(extracted_xo_dir / "xo.xml")
        xo_xml_kernel = xo_xml_tree.getroot().find("./Kernels/Kernel")
        assert xo_xml_kernel is not None
        self.xo_ip_relpath = (
            Path(xo_xml_kernel.attrib["TopIpDir"]) / xo_xml_kernel.attrib["IP"]
        )
        rtl_src_dir = extracted_xo_dir / self.xo_ip_relpath / "src"
        _logger.info("Using RTL source directory: %s", rtl_src_dir)
        report_dir = extracted_xo_dir / "report"
        _logger.info("Using HLS report directory: %s", report_dir)
        top_module_name = xo_xml_kernel.attrib["Name"]
        self.set_top_module_name(top_module_name)
        self.add_flatten_targets([top_module_name])
        _logger.info("Setting top module name: %s", top_module_name)

        # Add source files and reports to the project.
        self.add_vlog_files(list(rtl_src_dir.glob("*.v")))
        self.add_xci_files(list(rtl_src_dir.rglob("*.xci")))
        self.add_hls_report_dirs([report_dir])

    # @override
    def export_project(self, disable_syntax_check: bool = True) -> Path:
        """Export the transformed project.

        If the project has an input XO file added, in addition to the standard project
        outputs, a "{top_module_name}.xo" file will be generated under the `exported`
        directory.
        """
        assert self.top_module_name is not None

        exported_design_path = super().export_project(disable_syntax_check)
        if hasattr(self, "xo_file"):
            output_xo = self.work_dir / EXPORTED_PATH / f"{self.top_module_name}.xo"
            hdl_dir = self.work_dir / EXPORTED_DESIGN_PATH

            package_xo_dir = self.work_dir / GENERATED_PACKAGE_XO_DIR
            package_xo_dir.mkdir(parents=True, exist_ok=True)

            self.export_xo_from_project(hdl_dir, output_xo, package_xo_dir)

        return exported_design_path

    def export_xo_from_project(
        self, hdl_dir: Path, output_xo_file: Path, package_xo_dir: Path
    ) -> None:
        """Export the project as an XO file.

        In DSE environment, we will generate different RTLs and reuse this utility to
        export the XO file for each candidate solution.
        """
        assert self.top_module_name is not None

        extracted_xo_dir = self.work_dir / GENERATED_XO_DIR
        component_xml_path = extracted_xo_dir / self.xo_ip_relpath / "component.xml"

        kernel_xml_path = extracted_xo_dir / self.top_module_name / "kernel.xml"

        parameterized_export_xo_file(
            kernel_xml_path=kernel_xml_path,
            component_xml_path=component_xml_path,
            top_module_name=self.top_module_name,
            hdl_dir=hdl_dir,
            package_xo_dir=package_xo_dir,
            output_xo_file=output_xo_file,
        )

    def run_dse(self) -> None:
        """Run pre-autobridge passes and then perform DSE on AutoBridge."""
        # check vitis-specific fields have been set
        assert hasattr(self, "vitis_platform"), "Vitis platform not set"
        assert hasattr(self, "connectivity_ini"), "Vitis connectivity config not set"

        work_dir_to_ir = self.run_dse_until_add_pipeline()

        # export
        work_dir_to_vpp_sh = self.parallel_export_candidates(work_dir_to_ir)

        self.run_parallel_vpp(work_dir_to_vpp_sh)

    def parallel_export_candidates(
        self, work_dir_to_ir: dict[Path, Path]
    ) -> dict[Path, Path]:
        """Export the candidates in parallel."""
        work_dir_to_vpp_sh: dict[Path, Path] = {}
        assert self.top_module_name is not None
        with concurrent.futures.ProcessPoolExecutor() as executor:
            # Create a list of futures
            futures = [
                executor.submit(
                    self.export_candidate,
                    local_dir,
                    post_pp_ir,
                    self.port_to_clock_period,
                )
                for local_dir, post_pp_ir in work_dir_to_ir.items()
            ]

            # As each future completes, update the dictionary
            for future in concurrent.futures.as_completed(futures):
                local_dir, impl_tcl = future.result()
                work_dir_to_vpp_sh[local_dir] = impl_tcl

        return work_dir_to_vpp_sh

    def export_candidate(
        self,
        local_dir: Path,
        add_pipeline_json: Path,
        port_to_clock_period: dict[str, float],
    ) -> tuple[Path, Path]:
        """Process the DSE candidate and generate the implementation script.

        Returns:
            tuple[Path, Path]: The local directory and the v++ script for each solution.
        """
        paramterized_export_project(
            work_dir=local_dir,
            input_json_path=add_pipeline_json,
            port_to_clock_period=port_to_clock_period,
            disable_syntax_check=True,
        )

        xo_path = local_dir / EXPORTED_PATH / f"{self.top_module_name}.xo"
        package_xo_dir = local_dir / GENERATED_PACKAGE_XO_DIR
        package_xo_dir.mkdir(parents=True, exist_ok=True)

        vpp_script = self.generate_vpp_script(local_dir, xo_path)

        self.export_xo_from_project(
            hdl_dir=local_dir / EXPORTED_DESIGN_PATH,
            output_xo_file=xo_path,
            package_xo_dir=package_xo_dir,
        )

        return local_dir, vpp_script

    def generate_vpp_script(self, local_dir: Path, xo_path: Path) -> Path:
        """Generate the v++ script for the candidate solution."""
        _logger.info(f"Generating v++ script for {xo_path}")
        assert len(self.port_to_clock_period) == 1
        target_freq_mhz = int(1000 / list(self.port_to_clock_period.values())[0])

        vpp_script = local_dir / EXPORTED_IMPL_PATH / "run_vitis.sh"
        vpp_script.write_text(
            jinja2.Template(Path(VPP_TEMPLATE).read_text(encoding="utf-8")).render(
                top=self.top_module_name,
                xo_path=xo_path,
                constraint_path=local_dir / EXPORTER_XDC_FLOORPLAN_PATH,
                ini_connectivity_config=self.connectivity_ini,
                target_frequency=target_freq_mhz,
                platform=self.vitis_platform,
            ),
            encoding="utf-8",
        )

        return vpp_script

    def run_parallel_vpp(self, work_dir_to_vpp_sh: dict[Path, Path]) -> None:
        """Run Vitis for each candidate in parallel and export."""
        _logger.info("Running Vitis for each candidate...")

        # run each vpp_sh using bash with subprocess in parallel
        work_dir_to_proc: dict[Path, subprocess.Popen[Any]] = {}
        for local_dir, vpp_sh in work_dir_to_vpp_sh.items():
            with open(f"{local_dir}/vpp.log", "w", encoding="utf-8") as f:
                work_dir_to_proc[local_dir] = (
                    subprocess.Popen(  # pylint: disable=consider-using-with
                        ["bash", vpp_sh],
                        cwd=local_dir,
                        stdout=f,
                        stderr=subprocess.PIPE,
                        text=True,
                        bufsize=1,  # line buffer
                    )
                )

        # collect results
        for local_dir, proc in work_dir_to_proc.items():
            proc.wait()

            if proc.returncode != 0:
                raise RuntimeError(f"Error running Vitis for {local_dir}")
