# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_found_error import NotFoundError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...types.create_connector_o_auth import CreateConnectorOAuth
from ...types.create_connector_response import CreateConnectorResponse
from ...types.create_connector_service_auth import CreateConnectorServiceAuth
from ...types.delete_connector_response import DeleteConnectorResponse
from ...types.get_connector_response import GetConnectorResponse
from ...types.list_connectors_response import ListConnectorsResponse
from ...types.o_auth_authorize_response import OAuthAuthorizeResponse
from ...types.update_connector_response import UpdateConnectorResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ConnectorsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self, *, limit: typing.Optional[float] = None, offset: typing.Optional[float] = None
    ) -> ListConnectorsResponse:
        """
        Returns a list of connectors ordered by descending creation date (newer first). See ['Managing your Connector'](https://docs.cohere.com/docs/managing-your-connector) for more information.

        Parameters:
            - limit: typing.Optional[float]. Maximum number of connectors to return [0, 100].

            - offset: typing.Optional[float]. Number of connectors to skip before returning results [0, inf].
        ---
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.connectors.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/connectors"),
            params=remove_none_from_dict({"limit": limit, "offset": offset}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListConnectorsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        url: str,
        excludes: typing.Optional[typing.List[str]] = OMIT,
        oauth: typing.Optional[CreateConnectorOAuth] = OMIT,
        active: typing.Optional[bool] = OMIT,
        continue_on_failure: typing.Optional[bool] = OMIT,
        service_auth: typing.Optional[CreateConnectorServiceAuth] = OMIT,
    ) -> CreateConnectorResponse:
        """
        Creates a new connector. The connector is tested during registration and will cancel registration when the test is unsuccessful. See ['Creating and Deploying a Connector'](https://docs.cohere.com/docs/creating-and-deploying-a-connector) for more information.

        Parameters:
            - name: str. A human-readable name for the connector.

            - description: typing.Optional[str]. A description of the connector.

            - url: str. The URL of the connector that will be used to search for documents.

            - excludes: typing.Optional[typing.List[str]]. A list of fields to exclude from the prompt (fields remain in the document).

            - oauth: typing.Optional[CreateConnectorOAuth]. The OAuth 2.0 configuration for the connector. Cannot be specified if service_auth is specified.

            - active: typing.Optional[bool]. Whether the connector is active or not.

            - continue_on_failure: typing.Optional[bool]. Whether a chat request should continue or not if the request to this connector fails.

            - service_auth: typing.Optional[CreateConnectorServiceAuth]. The service to service authentication configuration for the connector. Cannot be specified if oauth is specified.
        ---
        from cohere import (
            AuthTokenType,
            CreateConnectorOAuth,
            CreateConnectorServiceAuth,
        )
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.connectors.create(
            name="string",
            url="string",
            oauth=CreateConnectorOAuth(),
            service_auth=CreateConnectorServiceAuth(
                type=AuthTokenType.BEARER,
                token="string",
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "url": url}
        if description is not OMIT:
            _request["description"] = description
        if excludes is not OMIT:
            _request["excludes"] = excludes
        if oauth is not OMIT:
            _request["oauth"] = oauth
        if active is not OMIT:
            _request["active"] = active
        if continue_on_failure is not OMIT:
            _request["continue_on_failure"] = continue_on_failure
        if service_auth is not OMIT:
            _request["service_auth"] = service_auth
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/connectors"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateConnectorResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, id: str) -> GetConnectorResponse:
        """
        Retrieve a connector by ID. See ['Connectors'](https://docs.cohere.com/docs/connectors) for more information.

        Parameters:
            - id: str. The ID of the connector to retrieve.
        ---
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.connectors.get(
            id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/connectors/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetConnectorResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, id: str) -> DeleteConnectorResponse:
        """
        Delete a connector by ID. See ['Connectors'](https://docs.cohere.com/docs/connectors) for more information.

        Parameters:
            - id: str. The ID of the connector to delete.
        ---
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.connectors.delete(
            id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/connectors/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteConnectorResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        id: str,
        *,
        name: typing.Optional[str] = OMIT,
        url: typing.Optional[str] = OMIT,
        excludes: typing.Optional[typing.List[str]] = OMIT,
        oauth: typing.Optional[CreateConnectorOAuth] = OMIT,
        active: typing.Optional[bool] = OMIT,
        continue_on_failure: typing.Optional[bool] = OMIT,
        service_auth: typing.Optional[CreateConnectorServiceAuth] = OMIT,
    ) -> UpdateConnectorResponse:
        """
        Update a connector by ID. Omitted fields will not be updated. See ['Managing your Connector'](https://docs.cohere.com/docs/managing-your-connector) for more information.

        Parameters:
            - id: str. The ID of the connector to update.

            - name: typing.Optional[str]. A human-readable name for the connector.

            - url: typing.Optional[str]. The URL of the connector that will be used to search for documents.

            - excludes: typing.Optional[typing.List[str]]. A list of fields to exclude from the prompt (fields remain in the document).

            - oauth: typing.Optional[CreateConnectorOAuth]. The OAuth 2.0 configuration for the connector. Cannot be specified if service_auth is specified.

            - active: typing.Optional[bool].

            - continue_on_failure: typing.Optional[bool].

            - service_auth: typing.Optional[CreateConnectorServiceAuth]. The service to service authentication configuration for the connector. Cannot be specified if oauth is specified.
        ---
        from cohere import (
            AuthTokenType,
            CreateConnectorOAuth,
            CreateConnectorServiceAuth,
        )
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.connectors.update(
            id="string",
            oauth=CreateConnectorOAuth(),
            service_auth=CreateConnectorServiceAuth(
                type=AuthTokenType.BEARER,
                token="string",
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if url is not OMIT:
            _request["url"] = url
        if excludes is not OMIT:
            _request["excludes"] = excludes
        if oauth is not OMIT:
            _request["oauth"] = oauth
        if active is not OMIT:
            _request["active"] = active
        if continue_on_failure is not OMIT:
            _request["continue_on_failure"] = continue_on_failure
        if service_auth is not OMIT:
            _request["service_auth"] = service_auth
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/connectors/{id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UpdateConnectorResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def o_auth_authorize(self, id: str, *, after_token_redirect: typing.Optional[str] = None) -> OAuthAuthorizeResponse:
        """
        Authorize the connector with the given ID for the connector oauth app. See ['Connector Authentication'](https://docs.cohere.com/docs/connector-authentication) for more information.

        Parameters:
            - id: str. The ID of the connector to authorize.

            - after_token_redirect: typing.Optional[str]. The URL to redirect to after the connector has been authorized.
        ---
        from cohere.client import Client

        client = Client(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        client.connectors.o_auth_authorize(
            id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/connectors/{id}/oauth/authorize"),
            params=remove_none_from_dict({"after_token_redirect": after_token_redirect}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OAuthAuthorizeResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncConnectorsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self, *, limit: typing.Optional[float] = None, offset: typing.Optional[float] = None
    ) -> ListConnectorsResponse:
        """
        Returns a list of connectors ordered by descending creation date (newer first). See ['Managing your Connector'](https://docs.cohere.com/docs/managing-your-connector) for more information.

        Parameters:
            - limit: typing.Optional[float]. Maximum number of connectors to return [0, 100].

            - offset: typing.Optional[float]. Number of connectors to skip before returning results [0, inf].
        ---
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.connectors.list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/connectors"),
            params=remove_none_from_dict({"limit": limit, "offset": offset}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListConnectorsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        url: str,
        excludes: typing.Optional[typing.List[str]] = OMIT,
        oauth: typing.Optional[CreateConnectorOAuth] = OMIT,
        active: typing.Optional[bool] = OMIT,
        continue_on_failure: typing.Optional[bool] = OMIT,
        service_auth: typing.Optional[CreateConnectorServiceAuth] = OMIT,
    ) -> CreateConnectorResponse:
        """
        Creates a new connector. The connector is tested during registration and will cancel registration when the test is unsuccessful. See ['Creating and Deploying a Connector'](https://docs.cohere.com/docs/creating-and-deploying-a-connector) for more information.

        Parameters:
            - name: str. A human-readable name for the connector.

            - description: typing.Optional[str]. A description of the connector.

            - url: str. The URL of the connector that will be used to search for documents.

            - excludes: typing.Optional[typing.List[str]]. A list of fields to exclude from the prompt (fields remain in the document).

            - oauth: typing.Optional[CreateConnectorOAuth]. The OAuth 2.0 configuration for the connector. Cannot be specified if service_auth is specified.

            - active: typing.Optional[bool]. Whether the connector is active or not.

            - continue_on_failure: typing.Optional[bool]. Whether a chat request should continue or not if the request to this connector fails.

            - service_auth: typing.Optional[CreateConnectorServiceAuth]. The service to service authentication configuration for the connector. Cannot be specified if oauth is specified.
        ---
        from cohere import (
            AuthTokenType,
            CreateConnectorOAuth,
            CreateConnectorServiceAuth,
        )
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.connectors.create(
            name="string",
            url="string",
            oauth=CreateConnectorOAuth(),
            service_auth=CreateConnectorServiceAuth(
                type=AuthTokenType.BEARER,
                token="string",
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "url": url}
        if description is not OMIT:
            _request["description"] = description
        if excludes is not OMIT:
            _request["excludes"] = excludes
        if oauth is not OMIT:
            _request["oauth"] = oauth
        if active is not OMIT:
            _request["active"] = active
        if continue_on_failure is not OMIT:
            _request["continue_on_failure"] = continue_on_failure
        if service_auth is not OMIT:
            _request["service_auth"] = service_auth
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/connectors"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateConnectorResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, id: str) -> GetConnectorResponse:
        """
        Retrieve a connector by ID. See ['Connectors'](https://docs.cohere.com/docs/connectors) for more information.

        Parameters:
            - id: str. The ID of the connector to retrieve.
        ---
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.connectors.get(
            id="string",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/connectors/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetConnectorResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, id: str) -> DeleteConnectorResponse:
        """
        Delete a connector by ID. See ['Connectors'](https://docs.cohere.com/docs/connectors) for more information.

        Parameters:
            - id: str. The ID of the connector to delete.
        ---
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.connectors.delete(
            id="string",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/connectors/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteConnectorResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        id: str,
        *,
        name: typing.Optional[str] = OMIT,
        url: typing.Optional[str] = OMIT,
        excludes: typing.Optional[typing.List[str]] = OMIT,
        oauth: typing.Optional[CreateConnectorOAuth] = OMIT,
        active: typing.Optional[bool] = OMIT,
        continue_on_failure: typing.Optional[bool] = OMIT,
        service_auth: typing.Optional[CreateConnectorServiceAuth] = OMIT,
    ) -> UpdateConnectorResponse:
        """
        Update a connector by ID. Omitted fields will not be updated. See ['Managing your Connector'](https://docs.cohere.com/docs/managing-your-connector) for more information.

        Parameters:
            - id: str. The ID of the connector to update.

            - name: typing.Optional[str]. A human-readable name for the connector.

            - url: typing.Optional[str]. The URL of the connector that will be used to search for documents.

            - excludes: typing.Optional[typing.List[str]]. A list of fields to exclude from the prompt (fields remain in the document).

            - oauth: typing.Optional[CreateConnectorOAuth]. The OAuth 2.0 configuration for the connector. Cannot be specified if service_auth is specified.

            - active: typing.Optional[bool].

            - continue_on_failure: typing.Optional[bool].

            - service_auth: typing.Optional[CreateConnectorServiceAuth]. The service to service authentication configuration for the connector. Cannot be specified if oauth is specified.
        ---
        from cohere import (
            AuthTokenType,
            CreateConnectorOAuth,
            CreateConnectorServiceAuth,
        )
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.connectors.update(
            id="string",
            oauth=CreateConnectorOAuth(),
            service_auth=CreateConnectorServiceAuth(
                type=AuthTokenType.BEARER,
                token="string",
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if url is not OMIT:
            _request["url"] = url
        if excludes is not OMIT:
            _request["excludes"] = excludes
        if oauth is not OMIT:
            _request["oauth"] = oauth
        if active is not OMIT:
            _request["active"] = active
        if continue_on_failure is not OMIT:
            _request["continue_on_failure"] = continue_on_failure
        if service_auth is not OMIT:
            _request["service_auth"] = service_auth
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/connectors/{id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UpdateConnectorResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def o_auth_authorize(
        self, id: str, *, after_token_redirect: typing.Optional[str] = None
    ) -> OAuthAuthorizeResponse:
        """
        Authorize the connector with the given ID for the connector oauth app. See ['Connector Authentication'](https://docs.cohere.com/docs/connector-authentication) for more information.

        Parameters:
            - id: str. The ID of the connector to authorize.

            - after_token_redirect: typing.Optional[str]. The URL to redirect to after the connector has been authorized.
        ---
        from cohere.client import AsyncClient

        client = AsyncClient(
            client_name="YOUR_CLIENT_NAME",
            token="YOUR_TOKEN",
        )
        await client.connectors.o_auth_authorize(
            id="string",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/connectors/{id}/oauth/authorize"),
            params=remove_none_from_dict({"after_token_redirect": after_token_redirect}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(OAuthAuthorizeResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
