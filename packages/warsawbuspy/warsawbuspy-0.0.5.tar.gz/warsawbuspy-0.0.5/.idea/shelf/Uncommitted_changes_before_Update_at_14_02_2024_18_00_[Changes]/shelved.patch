Index: buspy/readers/data_reader.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nimport csv\r\nimport os\r\nimport requests\r\n\r\nfrom buspy.data_holders.data_holders import ZTMBus, BusStop, BusForStop, BusScheduleEntry, BusRouteEntry\r\nimport datetime\r\n\r\n\r\nclass DataReader:\r\n    __slots__ = ('__api_key', '__bus_data', '__bus_stop_data', '__buses_for_stops', '__schedules', '__bus_routes')\r\n\r\n    def __init__(self, api_key):\r\n        self.__api_key = api_key\r\n        self.__bus_data = {}\r\n        self.__bus_stop_data = {}\r\n        self.__buses_for_stops = {}\r\n        self.__schedules = {}\r\n        self.__bus_routes = {}\r\n\r\n    @property\r\n    def api_key(self):\r\n        return self.__api_key\r\n\r\n    @property\r\n    def bus_data(self):\r\n        return self.__bus_data\r\n\r\n    @property\r\n    def bus_stop_data(self):\r\n        return self.__bus_stop_data\r\n\r\n    @property\r\n    def buses_for_stops(self):\r\n        return self.__buses_for_stops\r\n\r\n    @property\r\n    def schedules(self):\r\n        return self.__schedules\r\n\r\n    @property\r\n    def bus_routes(self):\r\n        return self.__bus_routes\r\n\r\n    @staticmethod\r\n    def time_parser(time_data):\r\n        if time_data[:2] == '24':\r\n            time_data = '00' + time_data[2:]\r\n        elif time_data[:2] == '25':\r\n            time_data = '01' + time_data[2:]\r\n        elif time_data[:2] == '26':\r\n            time_data = '02' + time_data[2:]\r\n        elif time_data[:2] == '27':\r\n            time_data = '03' + time_data[2:]\r\n        elif time_data[:2] == '28':\r\n            time_data = '04' + time_data[2:]\r\n        elif time_data[:2] == '29':\r\n            time_data = '05' + time_data[2:]\r\n\r\n        return time_data\r\n\r\n    def get_bus_data(self, nr_of_samples, sample_length):\r\n        url = ('https://api.um.warszawa.pl/api/action/busestrams_get/?resource_id= '\r\n               'f2e5503e-927d-4ad3-9500-4ab9e55deb59&apikey=') + self.__api_key + '&type=1'\r\n        for i in range(nr_of_samples):\r\n            response = requests.get(url)\r\n            while response.status_code != 200 or response.json()['result'][0] == 'B':\r\n                response = requests.get(url)\r\n            for j in range(len(response.json()['result'])):\r\n                helper = response.json()['result'][j]\r\n                time_data = self.time_parser(helper['Time'])\r\n                if helper['Lines'][0] != 'Z':\r\n                    bus = ZTMBus(helper['Lines'], helper['Lon'], helper['Lat'], helper['VehicleNumber'],\r\n                                 helper['Brigade'], time_data)\r\n\r\n                    if helper['Lines'] in self.__bus_data:\r\n                        self.__bus_data[helper['Lines']].append(bus)\r\n                    else:\r\n                        self.__bus_data[helper['Lines']] = [bus]\r\n\r\n            time.sleep(sample_length)\r\n\r\n    def dump_bus_data(self, file_to_dump, time_offset=-1):\r\n        time_data = datetime.datetime.now(datetime.timezone.utc)\r\n        time_in_sec = (time_data.hour + 1) * 60\r\n        time_in_sec += time_data.minute\r\n        time_in_sec *= 60\r\n        time_in_sec += int(time_data.second)\r\n        data_headers = ['Lines', 'Longitude', 'Latitude', 'Street_name', 'VehicleNumber', 'Brigade', 'Time']\r\n        with open(file_to_dump, 'w', newline='', encoding='utf16') as file:\r\n            csv_writer = csv.writer(file)\r\n            csv_writer.writerow(data_headers)\r\n            for key in self.__bus_data:\r\n                for value in self.__bus_data[key]:\r\n                    if 0 < time_offset < abs(value.time_data - time_in_sec):\r\n                        continue\r\n                    value.location.find_street()\r\n                    csv_writer.writerow(value.to_csv())\r\n\r\n    def get_stops_data(self):\r\n        response = requests.get(\r\n            'https://api.um.warszawa.pl/api/action/dbstore_get/?id=ab75c33d-3a26-4342-b36a-6e5fef0a3ac3&page=1')\r\n        for data in response.json()['result']:\r\n            bs = BusStop(data['values'][2]['value'], data['values'][3]['value'], data['values'][0]['value'],\r\n                         data['values'][1]['value'], data['values'][6]['value'],\r\n                         float(data['values'][5]['value']), float(data['values'][4]['value']))\r\n\r\n            if bs.team_name in self.__bus_stop_data:\r\n                self.__bus_stop_data[bs.team_name].append(bs)\r\n            else:\r\n                self.__bus_stop_data[bs.team_name] = [bs]\r\n\r\n            print(data['values'])\r\n\r\n    def dump_stops_data(self, file_to_dump):\r\n        data_headers = ['Team_name', 'Street_id', 'Team', 'Post', 'Direction', 'Longitude', 'Latitude']\r\n        with open(file_to_dump, 'w', newline='', encoding='utf16') as file:\r\n            csv_writer = csv.writer(file)\r\n            csv_writer.writerow(data_headers)\r\n            for key in self.__bus_stop_data:\r\n                for value in self.__bus_stop_data[key]:\r\n                    csv_writer.writerow(value.to_csv())\r\n\r\n    def get_buses_for_stops(self, bus_stop_list_file):\r\n        with open(bus_stop_list_file, 'r', encoding='utf16') as file:\r\n            csv_reader = csv.reader(file)\r\n            nr_of_lines = 0\r\n            for line in csv_reader:\r\n                nr_of_lines = nr_of_lines + 1\r\n                if nr_of_lines > 1 and line[2] != 'null' and line[3] != 'null':\r\n                    response = requests.get(\r\n                        'https://api.um.warszawa.pl/api/action/dbtimetable_get/?id=88cd555f-6f31-43ca-9de4'\r\n                        '-66c479ad5942&busstopId=' +\r\n                        line[2] + '&busstopNr=' + line[3] + '&apikey=' + self.__api_key)\r\n                    for data in response.json()['result']:\r\n                        bus = BusForStop(line[2], line[3], data['values'][0]['value'])\r\n                        if len(bus.bus) == 3:\r\n                            if bus.team in self.__buses_for_stops:\r\n                                self.__buses_for_stops[bus.team].append(bus)\r\n                            else:\r\n                                self.__buses_for_stops[bus.team] = [bus]\r\n\r\n    def dump_buses_for_stops(self, file_to_dump):\r\n        data_headers = ['Team', 'Post', 'Bus']\r\n        with open(file_to_dump, 'w', newline='', encoding='utf16') as file:\r\n            csv_writer = csv.writer(file)\r\n            csv_writer.writerow(data_headers)\r\n            for key in self.__buses_for_stops:\r\n                for data in self.__buses_for_stops[key]:\r\n                    csv_writer.writerow(data.to_csv())\r\n\r\n    def get_bus_schedules(self, __buses_for_stops_file):\r\n        with open(__buses_for_stops_file, 'r', encoding='utf16') as file:\r\n            csv_reader = csv.reader(file)\r\n            nr_of_lines = 0\r\n            for line in csv_reader:\r\n                nr_of_lines = nr_of_lines + 1\r\n                if nr_of_lines > 1 and len(line) == 3:\r\n                    response = requests.get(\r\n                        'https://api.um.warszawa.pl/api/action/dbtimetable_get/?id=e923fa0e-d96c-43f9-ae6e'\r\n                        '-60518c9f3238&busstopId=' +\r\n                        line[0] + '&busstopNr=' + line[1] + '&line=' + line[2] + '&apikey=' + self.__api_key)\r\n                    for data in response.json()['result']:\r\n                        time_data = self.time_parser(data['values'][5]['value'])\r\n                        scl = BusScheduleEntry(data['values'][2]['value'], data['values'][3]['value'],\r\n                                               data['values'][4]['value'], time_data)\r\n                        if line[0] in self.__schedules:\r\n                            if line[1] in self.__schedules[line[0]]:\r\n                                if line[2] in self.__schedules[line[0]][line[1]]:\r\n                                    self.__schedules[line[0]][line[1]][line[2]].append(scl)\r\n                                else:\r\n                                    self.__schedules[line[0]][line[1]][line[2]] = [scl]\r\n                            else:\r\n                                self.__schedules[line[0]][line[1]] = {line[2]: [scl]}\r\n                        else:\r\n                            self.__schedules[line[0]] = {line[1]: {line[2]: [scl]}}\r\n\r\n    def dump_schedules(self, folder_to_store_in):\r\n        data_headers = ['Brigade', 'Direction', 'Route', 'Time']\r\n        if not os.path.isdir(folder_to_store_in):\r\n            os.mkdir(folder_to_store_in)\r\n        for team in self.__schedules:\r\n            for post in self.__schedules[team]:\r\n                for bus in self.__schedules[team][post]:\r\n                    with open(folder_to_store_in + '/' + team + '_' + post + '_' + bus + '.csv', 'w',\r\n                              newline='', encoding='utf16') as file:\r\n                        csv_writer = csv.writer(file)\r\n                        csv_writer.writerow(data_headers)\r\n                        for data in self.__schedules[team][post][bus]:\r\n                            csv_writer.writerow(data.to_csv())\r\n\r\n    def get_bus_routes(self):\r\n        response = requests.get(\r\n            'https://api.um.warszawa.pl/api/action/public_transport_routes/?apikey=' + self.__api_key)\r\n        for bus_nr in response.json()['result']:\r\n            for route_type in response.json()['result'][bus_nr]:\r\n                max_nr = 0\r\n                for nr in response.json()['result'][bus_nr][route_type]:\r\n                    if int(nr) > max_nr:\r\n                        max_nr = int(nr)\r\n                if bus_nr not in self.__bus_routes:\r\n                    self.__bus_routes[bus_nr] = {}\r\n                self.__bus_routes[bus_nr][route_type] = {}\r\n                for i in range(max_nr):\r\n                    self.__bus_routes[bus_nr][route_type][i + 1] = None\r\n                for nr in response.json()['result'][bus_nr][route_type]:\r\n                    helper = response.json()['result'][bus_nr][route_type][nr]\r\n                    self.__bus_routes[bus_nr][route_type][int(nr)] = (\r\n                        BusRouteEntry(bus_nr, route_type, helper['ulica_id'], helper['nr_zespolu'],\r\n                                      helper['typ'], helper['nr_przystanku']))\r\n\r\n    def dump_bus_routes(self, file_to_dump):\r\n        data_headers = ['Bus_nr', 'Route_code', 'Street_id', 'Team_nr', 'Type', 'Bus_stop_nr']\r\n        with open(file_to_dump, 'w', newline='', encoding='utf16') as file:\r\n            csv_writer = csv.writer(file)\r\n            csv_writer.writerow(data_headers)\r\n            for bus_nr in self.__bus_routes:\r\n                for route_type in self.__bus_routes[bus_nr]:\r\n                    for data in self.__bus_routes[bus_nr][route_type]:\r\n                        csv_writer.writerow(self.__bus_routes[bus_nr][route_type][data].to_csv())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/buspy/readers/data_reader.py b/buspy/readers/data_reader.py
--- a/buspy/readers/data_reader.py	(revision e166145010d70dc549435f9a3585e777c5e39464)
+++ b/buspy/readers/data_reader.py	(date 1707930037757)
@@ -42,23 +42,15 @@
     def bus_routes(self):
         return self.__bus_routes
 
+    # API sends times like '25:01:24' for schedules etc., so this function parses that back
+    # into normal time format (for 25:00:00 it would be 01:00:00).
     @staticmethod
     def time_parser(time_data):
-        if time_data[:2] == '24':
-            time_data = '00' + time_data[2:]
-        elif time_data[:2] == '25':
-            time_data = '01' + time_data[2:]
-        elif time_data[:2] == '26':
-            time_data = '02' + time_data[2:]
-        elif time_data[:2] == '27':
-            time_data = '03' + time_data[2:]
-        elif time_data[:2] == '28':
-            time_data = '04' + time_data[2:]
-        elif time_data[:2] == '29':
-            time_data = '05' + time_data[2:]
-
+        if '24' <= time_data[:2] <= '29':
+            time_data = '0' + str(int(time_data[:2]) % 24) + time_data[2:]
         return time_data
 
+    # Function that retrieves data bout bus locations every 'sample_length' seconds 'nr_of_samples' times.
     def get_bus_data(self, nr_of_samples, sample_length):
         url = ('https://api.um.warszawa.pl/api/action/busestrams_get/?resource_id= '
                'f2e5503e-927d-4ad3-9500-4ab9e55deb59&apikey=') + self.__api_key + '&type=1'
@@ -69,17 +61,18 @@
             for j in range(len(response.json()['result'])):
                 helper = response.json()['result'][j]
                 time_data = self.time_parser(helper['Time'])
-                if helper['Lines'][0] != 'Z':
+                if helper['Lines'][0] != 'Z':  # Those are replacement buses, and there are problems with them
+                    # not having schedules or routes or etc., and there are only four of them, so I ignore them.
                     bus = ZTMBus(helper['Lines'], helper['Lon'], helper['Lat'], helper['VehicleNumber'],
                                  helper['Brigade'], time_data)
-
                     if helper['Lines'] in self.__bus_data:
                         self.__bus_data[helper['Lines']].append(bus)
                     else:
                         self.__bus_data[helper['Lines']] = [bus]
-
+            # Waiting for the next sampling.
             time.sleep(sample_length)
 
+    # Function that stores all the gathered data about buses locations into the given file.
     def dump_bus_data(self, file_to_dump, time_offset=-1):
         time_data = datetime.datetime.now(datetime.timezone.utc)
         time_in_sec = (time_data.hour + 1) * 60
