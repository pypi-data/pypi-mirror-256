# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.


_autopystampl = False
try:
    import matplotlib.pyplot as pt
    _autpystampl=True
except:
    print("Error: matplotlib is not installed, drawing functions disabled")



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _autopysta
else:
    import _autopysta

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _autopysta.delete_SwigPyIterator

    def value(self):
        return _autopysta.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _autopysta.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _autopysta.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _autopysta.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _autopysta.SwigPyIterator_equal(self, x)

    def copy(self):
        return _autopysta.SwigPyIterator_copy(self)

    def next(self):
        return _autopysta.SwigPyIterator_next(self)

    def __next__(self):
        return _autopysta.SwigPyIterator___next__(self)

    def previous(self):
        return _autopysta.SwigPyIterator_previous(self)

    def advance(self, n):
        return _autopysta.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _autopysta.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _autopysta.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _autopysta.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _autopysta.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _autopysta.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _autopysta.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _autopysta:
_autopysta.SwigPyIterator_swigregister(SwigPyIterator)

def version():
    r""" Version"""
    return _autopysta.version()
class test(object):
    r"""
    Brief description about test class.

    More details about test class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def range_inc(number, min, max):
        r"""
        range_inc, takes three arguments.
               :type number: float
               :param number: Description about the param.
               :type min: float
               :param min: Description about the param.
               :type max: float
               :param max: Description about the param.
        """
        return _autopysta.test_range_inc(number, min, max)

    def __init__(self):
        _autopysta.test_swiginit(self, _autopysta.new_test())
    __swig_destroy__ = _autopysta.delete_test

# Register test in _autopysta:
_autopysta.test_swigregister(test)
class random_generator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def init():
        r""" Initialize the seed for the generators."""
        return _autopysta.random_generator_init()

    @staticmethod
    def uniform(a, b):
        r"""
         Returns a random value from a Uniform distribution.
                :type a: float
                :param a: Minimum Value.
                :type b: float
                :param b: Maximum Value.

        		:rtype: float
        :return: Returns a random value.
        """
        return _autopysta.random_generator_uniform(a, b)

    @staticmethod
    def uniform01():
        r"""
         Returns a random value from a Standard Uniform distribution.
        		:rtype: float
        :return: Returns a random value.
        """
        return _autopysta.random_generator_uniform01()

    @staticmethod
    def logistic(mu, s):
        r"""
         Returns a random value from a Logistic distribution.
        		:type mu: float
        :param mu: Location.
                :type s: float
                :param s: Scale.

        		:rtype: float
        :return: Returns a random value.
        """
        return _autopysta.random_generator_logistic(mu, s)

    @staticmethod
    def normal(mu, sigma):
        r"""
         Returns a random value from a Normal distribution.
                :type mu: float
                :param mu: Mean.
                :type sigma: float
                :param sigma: Standard deviation.

        		:rtype: float
        :return: Returns a random value.
        """
        return _autopysta.random_generator_normal(mu, sigma)

    def __init__(self):
        _autopysta.random_generator_swiginit(self, _autopysta.new_random_generator())
    __swig_destroy__ = _autopysta.delete_random_generator

# Register random_generator in _autopysta:
_autopysta.random_generator_swigregister(random_generator)
class params(object):
    r"""
    Brief description about params class.

    More details about params class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Constructor."""
        _autopysta.params_swiginit(self, _autopysta.new_params())
    __swig_destroy__ = _autopysta.delete_params

# Register params in _autopysta:
_autopysta.params_swigregister(params)
class params_cust(params):
    r"""
    Brief description about params_cust class.

    More details about params_cust class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    D = property(_autopysta.params_cust_D_get, _autopysta.params_cust_D_set, doc=r""" Description.""")

    def __init__(self):
        r""" Constructor."""
        _autopysta.params_cust_swiginit(self, _autopysta.new_params_cust())

    def add(self, new_name, new_value):
        r"""
        Function description.
                   :type new_name: string
                   :param new_name: Description.
                   :type new_value: float
                   :param new_value: Description.
        """
        return _autopysta.params_cust_add(self, new_name, new_value)

    def get(self, name):
        r"""
        Function description.
                   :type name: string
                   :param name: Key.

                   :rtype: float
                   :return: Value.
        """
        return _autopysta.params_cust_get(self, name)
    __swig_destroy__ = _autopysta.delete_params_cust

# Register params_cust in _autopysta:
_autopysta.params_cust_swigregister(params_cust)
class p_gipps(params):
    r"""
    Brief description about p_gipps class.

    More details about p_gipps class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    an = property(_autopysta.p_gipps_an_get, _autopysta.p_gipps_an_set, doc=r""" Maximum acceleration.""")
    bn = property(_autopysta.p_gipps_bn_get, _autopysta.p_gipps_bn_set, doc=r""" Maximum deceleration.""")
    sn = property(_autopysta.p_gipps_sn_get, _autopysta.p_gipps_sn_set, doc=r""" Jam spacing.""")
    vn = property(_autopysta.p_gipps_vn_get, _autopysta.p_gipps_vn_set, doc=r""" Free-flow speed.""")
    tau = property(_autopysta.p_gipps_tau_get, _autopysta.p_gipps_tau_set, doc=r""" Reaction time.""")
    bg = property(_autopysta.p_gipps_bg_get, _autopysta.p_gipps_bg_set, doc=r""" Leader's estimated maximum deceleration.""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
        p_gips Constructor.

        |

        *Overload 2:*
        Function description.
               :type an: float
               :param an:  Maximum acceleration.
               :type bn: float
               :param bn:  Maximum deceleration.
               :type sn: float
               :param sn:  Jam spacing.
               :type vn: float
               :param vn:  Free-flow speed.
               :type tau: float
               :param tau: Reaction time.
               :type bg: float
               :param bg:  Leader's estimated maximum deceleration.
        """
        _autopysta.p_gipps_swiginit(self, _autopysta.new_p_gipps(*args))
    __swig_destroy__ = _autopysta.delete_p_gipps

# Register p_gipps in _autopysta:
_autopysta.p_gipps_swigregister(p_gipps)
class p_idm(params):
    r"""
    Brief description about p_idm class.

    More details about p_idm class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    v0 = property(_autopysta.p_idm_v0_get, _autopysta.p_idm_v0_set, doc=r""" Max speed.""")
    T = property(_autopysta.p_idm_T_get, _autopysta.p_idm_T_set, doc=r""" Balance headway.""")
    a = property(_autopysta.p_idm_a_get, _autopysta.p_idm_a_set, doc=r""" Max acceleration.""")
    b = property(_autopysta.p_idm_b_get, _autopysta.p_idm_b_set, doc=r""" Max deceleration.""")
    dl = property(_autopysta.p_idm_dl_get, _autopysta.p_idm_dl_set, doc=r""" Exponent.""")
    s0 = property(_autopysta.p_idm_s0_get, _autopysta.p_idm_s0_set, doc=r""" Jam distance.""")
    l = property(_autopysta.p_idm_l_get, _autopysta.p_idm_l_set, doc=r""" Vehicle length.""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
        p_idm Constructor.
               Uses the default parameters:

               .. code-block:: c++

                       v0  = 120.0/3.6
                       T   = 1.6
                       a   = 0.73
                       b   = 1.67
                       dl  = 4
                       s0  = 2
                       l   = 5

        |

        *Overload 2:*
        2nd p_idm Constructor.
               :type v0: float
               :param v0: Max speed.
               :type T: float
               :param T: Balance headway.
               :type a: float
               :param a: Max acceleration.
               :type b: float
               :param b: Max deceleration.
               :type s0: float
               :param s0: Jam density.
               :type l: float
               :param l: Vehicle length.
        """
        _autopysta.p_idm_swiginit(self, _autopysta.new_p_idm(*args))
    __swig_destroy__ = _autopysta.delete_p_idm

# Register p_idm in _autopysta:
_autopysta.p_idm_swigregister(p_idm)
class p_linear(params):
    r"""
    Brief description about P_linear class.

    More details about p_linear class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    V = property(_autopysta.p_linear_V_get, _autopysta.p_linear_V_set)
    c1 = property(_autopysta.p_linear_c1_get, _autopysta.p_linear_c1_set)
    c2 = property(_autopysta.p_linear_c2_get, _autopysta.p_linear_c2_set)
    c3 = property(_autopysta.p_linear_c3_get, _autopysta.p_linear_c3_set)
    sr = property(_autopysta.p_linear_sr_get, _autopysta.p_linear_sr_set)
    tau = property(_autopysta.p_linear_tau_get, _autopysta.p_linear_tau_set)

    def __init__(self, *args):
        _autopysta.p_linear_swiginit(self, _autopysta.new_p_linear(*args))
    __swig_destroy__ = _autopysta.delete_p_linear

# Register p_linear in _autopysta:
_autopysta.p_linear_swigregister(p_linear)
class p_martinez_jin_2020(object):
    r"""
    Brief description about p_martinez_jin_2020 class.

    This class is for the Martinez and Jin parameters managment.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tau = property(_autopysta.p_martinez_jin_2020_tau_get, _autopysta.p_martinez_jin_2020_tau_set)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Creates a Newell model manager with default values for the parameters.

        |

        *Overload 2:*
         Creates a Newell model manager with given values for the parameters.
        		:type u: float
        :param u: Free-flow speed.
            		:type tau: float
        :param tau: Wave travel time.
        """
        _autopysta.p_martinez_jin_2020_swiginit(self, _autopysta.new_p_martinez_jin_2020(*args))
    __swig_destroy__ = _autopysta.delete_p_martinez_jin_2020

# Register p_martinez_jin_2020 in _autopysta:
_autopysta.p_martinez_jin_2020_swigregister(p_martinez_jin_2020)
class p_newell(params):
    r"""
    Brief description about p_newell class.

    This class is for the Newell parameters managment.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    u = property(_autopysta.p_newell_u_get, _autopysta.p_newell_u_set, doc=r""" Free-flow speed.""")
    w = property(_autopysta.p_newell_w_get, _autopysta.p_newell_w_set, doc=r""" Wave speed.""")
    kj = property(_autopysta.p_newell_kj_get, _autopysta.p_newell_kj_set, doc=r""" Jam density.""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Creates a Newell model manager with default values for the parameters.

        |

        *Overload 2:*
         Creates a Newell model manager with given values for the parameters.
        		:type u: float
        :param u: Free-flow speed.
            		:type w: float
        :param w: Wave speed.
            		:type kj: float
        :param kj: Jam density.
        """
        _autopysta.p_newell_swiginit(self, _autopysta.new_p_newell(*args))
    __swig_destroy__ = _autopysta.delete_p_newell

# Register p_newell in _autopysta:
_autopysta.p_newell_swigregister(p_newell)
class p_newell_random_acceleration(p_newell):
    r"""
    Brief description about p_newell_random_acceleration class.

    This class is for parameters of the Laval model based on the Newell model (Laval et al., 2014).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sigma_tilde = property(_autopysta.p_newell_random_acceleration_sigma_tilde_get, _autopysta.p_newell_random_acceleration_sigma_tilde_set, doc=r""" Standard Deviation Tilde.""")
    beta = property(_autopysta.p_newell_random_acceleration_beta_get, _autopysta.p_newell_random_acceleration_beta_set, doc=r""" Inverse Relaxation Time.""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Creates a Newell model manager with default values for the parameters.

        |

        *Overload 2:*
         Creates a Newell model manager with given values for the parameters.
        		:type sigma_tilde: float
        :param sigma_tilde:	//!< Standard Deviation Tilde.
            		:type beta: float
        :param beta:		//!< Inverse Relaxation Time.
        """
        _autopysta.p_newell_random_acceleration_swiginit(self, _autopysta.new_p_newell_random_acceleration(*args))
    __swig_destroy__ = _autopysta.delete_p_newell_random_acceleration

# Register p_newell_random_acceleration in _autopysta:
_autopysta.p_newell_random_acceleration_swigregister(p_newell_random_acceleration)
class point(object):
    r"""
    Brief description about point class.

    More details about point class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Point Constructor.
               :type _t: float
               :param _t: Time.
               :type _x: float
               :param _x: Position.
               :type _v: float
               :param _v: Speed.
               :type _a: float
               :param _a: Acceleration.
               :type _lane: int
               :param _lane: Lane.

        |

        *Overload 2:*
        Point duplicate
        """
        _autopysta.point_swiginit(self, _autopysta.new_point(*args))

    def to_str(self):
        r"""
        Get the point as string.
               :rtype: string
               :return: Point as string.
        """
        return _autopysta.point_to_str(self)

    def set_accel(self, _a):
        r"""
        Function description.
               :type _a: float
               :param _a: New acceleration.
        """
        return _autopysta.point_set_accel(self, _a)

    def set_velocity(self, _v):
        r"""
        Function description.
               :type _v: float
               :param _v: New velocity.
        """
        return _autopysta.point_set_velocity(self, _v)

    def set_x(self, _x):
        r"""
        Function description.
               :type _x: float
               :param _x: New possition.
        """
        return _autopysta.point_set_x(self, _x)

    def set_lane(self, _lane):
        r"""
        Function description.
               :type _lane: int
               :param _lane: New lane.
        """
        return _autopysta.point_set_lane(self, _lane)

    def reset_time(self):
        r""" Resets the point time attribute."""
        return _autopysta.point_reset_time(self)

    def T(self):
        r"""
        Function description.
               :rtype: float
               :return: Time value.
        """
        return _autopysta.point_T(self)

    def X(self):
        r"""
        Function description.
               :rtype: float
               :return: Position value.
        """
        return _autopysta.point_X(self)

    def V(self):
        r"""
        Function description.
               :rtype: float
               :return: Velocity value.
        """
        return _autopysta.point_V(self)

    def A(self):
        r"""
        Function description.
               :rtype: float
               :return: Acceleration value.
        """
        return _autopysta.point_A(self)

    def LANE(self):
        r"""
        Function description.
               :rtype: int
               :return: Lane value.
        """
        return _autopysta.point_LANE(self)
    __swig_destroy__ = _autopysta.delete_point

# Register point in _autopysta:
_autopysta.point_swigregister(point)
class generalized_trajectory(object):
    r"""
    Brief description about generalized_trajectory class.

    Base class from which trajectory and static_trajectory inherit.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def current(self):
        r"""
         Function description.
        		:rtype: :py:class:`point`
        :return: The current point of the trajectory.
        """
        return _autopysta.generalized_trajectory_current(self)
    __swig_destroy__ = _autopysta.delete_generalized_trajectory

# Register generalized_trajectory in _autopysta:
_autopysta.generalized_trajectory_swigregister(generalized_trajectory)
class trajectory(generalized_trajectory):
    r"""
    Brief description about trajectory class.

    Class that inherits from generalizaed_trayectory and also a vector.
    It stores points that the vehicles create when they update their path and can also returns points with the [] operator
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _point):
        r"""
         Creates a new trajectory with a starting point
        		:type _point: :py:class:`point`
        :param _point: Starting point of the trajectory
        """
        _autopysta.trajectory_swiginit(self, _autopysta.new_trajectory(_point))

    def push_back(self, p):
        r"""
         Function description.
        		:type p: :py:class:`point`
        :param p: Point.
        """
        return _autopysta.trajectory_push_back(self, p)

    def add(self, newPoint):
        r"""
         Pushes back a new point.
        		:type newPoint: :py:class:`point`
        :param newPoint: Description.

        		:rtype: :py:class:`point`
        :return: Returns the same given point.
        """
        return _autopysta.trajectory_add(self, newPoint)

    def get(self, i):
        r"""
         Gets a point.
        		:type i: int
        :param i: Index.

        		:rtype: :py:class:`point`
        :return: Returns the point at index i.
        """
        return _autopysta.trajectory_get(self, i)

    def len(self):
        r"""
         Get the length of the trajectory.
        		:rtype: int
        :return: Returns the length of the trajectory.
        """
        return _autopysta.trajectory_len(self)

    def current(self):
        r"""
         Get the current position.
        		:rtype: :py:class:`point`
        :return: Returns the actual point (position).
        """
        return _autopysta.trajectory_current(self)

    def __getitem__(self, i):
        return _autopysta.trajectory___getitem__(self, i)

    def __len__(self):
        return _autopysta.trajectory___len__(self)
    __swig_destroy__ = _autopysta.delete_trajectory

# Register trajectory in _autopysta:
_autopysta.trajectory_swigregister(trajectory)
class static_trajectory(generalized_trajectory):
    r"""
    Brief description about static_trajectory class.

    This is for a static object on the road (fixed_object).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        r""" Constructor."""
        _autopysta.static_trajectory_swiginit(self, _autopysta.new_static_trajectory(arg2))

    def current(self):
        r""" Get current position."""
        return _autopysta.static_trajectory_current(self)
    __swig_destroy__ = _autopysta.delete_static_trajectory

# Register static_trajectory in _autopysta:
_autopysta.static_trajectory_swigregister(static_trajectory)
class model(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def free_flow_speed(self, *args):
        return _autopysta.model_free_flow_speed(self, *args)

    def new_point(self, *args):
        return _autopysta.model_new_point(self, *args)
    __swig_destroy__ = _autopysta.delete_model

# Register model in _autopysta:
_autopysta.model_swigregister(model)
class gipps(model):
    r"""
    Gipps (1981) car-following model.

    Objects of this class manage the functionality related to
    vehicles' behavior according to the rules defined by Gipps's
    car-following model, including values for the parameters.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Creates a Gipps model manager with default values for the parameters.

        |

        *Overload 2:*
        Creates a Gipps model manager with values for the parameters given in p.
               :type p: :py:class:`p_gipps`
               :param p: A set of parameters for Gipps model.
        """
        _autopysta.gipps_swiginit(self, _autopysta.new_gipps(*args))

    def validate_parameters(self, *args):
        r"""
        Validate the model due to certain conditions the parameters have to meet.
               :type p: :py:class:`params`, optional
               :param p: Parameters for a car-following model.
        """
        return _autopysta.gipps_validate_parameters(self, *args)

    def equil_spcg(self, *args):
        r"""
        Computes the equilibrium spacing according to Gipps's model.
               :type vl: float
               :param vl: Leader's velocity.
               :type vf: float
               :param vf: Subject vehicle's (follower's) velocity.
               :type p: :py:class:`params`, optional
               :param p: Gipps model's parameters.

               :rtype: float
               :return: Returns a double.
        """
        return _autopysta.gipps_equil_spcg(self, *args)

    def wave_speed(self, leader, follower, p):
        r"""
        Not implemented yet.
               :type leader: :py:class:`point`
               :param leader: A point representing the leader's position and velocity.
               :type follower: :py:class:`point`
               :param follower: A point representing the follower's position and velocity.
               :type p: :py:class:`params`
               :param p: Gipps model's parameters.

               :rtype: float
               :return: Returns zero.
        """
        return _autopysta.gipps_wave_speed(self, leader, follower, p)

    def free_flow_speed(self, *args):
        r"""
        Gipps model's free-flow speed.
               :type p: :py:class:`params`, optional
               :param p: Gipps model's parameters.

               :rtype: float
               :return: Returns model's free-flow speed.
        """
        return _autopysta.gipps_free_flow_speed(self, *args)

    def new_point(self, *args):
        r"""
        Gipps model's new_point.
               :type leader: :py:class:`generalized_trajectory`
               :param leader: Generalized trajectory of the leader.
               :type follower: :py:class:`trajectory`
               :param follower: Trajectory of the follower.
               :type p: :py:class:`params`, optional
               :param p: Gipps parameters.

               :rtype: :py:class:`point`
               :return: Returns a new point.
        """
        return _autopysta.gipps_new_point(self, *args)
    __swig_destroy__ = _autopysta.delete_gipps

# Register gipps in _autopysta:
_autopysta.gipps_swigregister(gipps)
class idm(model):
    r"""
    Brief description about idm class

    (fecha)
    More details about creator class
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Function description.

        |

        *Overload 2:*
        Function description.
               :type pars: :py:class:`p_idm`
               :param pars: First param description.
        """
        _autopysta.idm_swiginit(self, _autopysta.new_idm(*args))

    def equil_spcg(self, *args):
        r"""
        Computes the equilibrium spacing according to IDM's model.
               :type vl: float
               :param vl: Leader's velocity.
               :type vf: float
               :param vf: Subject vehicle's (follower's) velocity.
               :param p: IDM model parameters.

               :rtype: float
               :return: Returns a double.
        """
        return _autopysta.idm_equil_spcg(self, *args)

    def wave_speed(self, leader, follower, p):
        r"""
        Not implemented yet.
               :type leader: :py:class:`point`
               :param leader: A point representing the leader's position and velocity.
               :type follower: :py:class:`point`
               :param follower: A point representing the follower's position and velocity.
               :type p: :py:class:`params`
               :param p: Intelligent driver model parameters.

               :rtype: float
               :return: Returns zero.
        """
        return _autopysta.idm_wave_speed(self, leader, follower, p)

    def free_flow_speed(self, *args):
        r"""
        IDM model free-flow speed.
               :type p: :py:class:`params`, optional
               :param p: IDM model parameters.

               :rtype: float
               :return: Returns model's free-flow speed.
        """
        return _autopysta.idm_free_flow_speed(self, *args)
    __swig_destroy__ = _autopysta.delete_idm

# Register idm in _autopysta:
_autopysta.idm_swigregister(idm)
class newell(model):
    r"""
    Newell (2002) car-following model.

    Objects of this class manage the functionality related to
    vehicles' behavior according to the rules defined by Newell's
    car-following model, including values for the parameters.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Creates a Newell model manager with default values for the parameters.

        |

        *Overload 2:*
        Creates a Newell model manager with values for the parameters given in p.
               :type p: :py:class:`p_newell`
               :param p: A set of parameters for Newell's model.
        """
        _autopysta.newell_swiginit(self, _autopysta.new_newell(*args))

    def equil_spcg(self, *args):
        r"""
        Computes the equilibrium spacing according to Newell's model.
               :type vl: float
               :param vl: Leader's velocity.
               :type vf: float
               :param vf: Subject vehicle's (follower's) velocity.
               :type p: :py:class:`params`, optional
               :param p: Newell model parameters.

               :rtype: float
               :return: Returns a double.
        """
        return _autopysta.newell_equil_spcg(self, *args)

    def wave_speed(self, leader, follower, p):
        r"""
        Returns the model's wave speed (i.e., parameter w).
               :type leader: :py:class:`point`
               :param leader: A point representing the leader's position and velocity.
               :type follower: :py:class:`point`
               :param follower: A point representing the follower's position and velocity.
               :type p: :py:class:`params`
               :param p: Newell model parameters.

               :rtype: float
               :return: Returns zero.
        """
        return _autopysta.newell_wave_speed(self, leader, follower, p)

    def free_flow_speed(self, *args):
        r"""
        Newell model free-flow speed.
               :type p: :py:class:`params`, optional
               :param p: Newell model parameters.

               :rtype: float
               :return: Returns model's free-flow speed.
        """
        return _autopysta.newell_free_flow_speed(self, *args)

    def new_point(self, *args):
        r"""
        Get the next point with the possitions of the leader and the follower.
               :type leader: :py:class:`generalized_trajectory`
               :param leader: Generalized trajectory representing the leader's position and speed int time. Leave null for no leader.
               :type follower: :py:class:`trajectory`
               :param follower: Trajectory representing the follower's position and speed in time. Leave null for no follower.
               :type p: :py:class:`params`, optional
               :param p: Parameters for Newell's car-following model.

               :rtype: :py:class:`point`
               :return: Next point.
        """
        return _autopysta.newell_new_point(self, *args)
    __swig_destroy__ = _autopysta.delete_newell

# Register newell in _autopysta:
_autopysta.newell_swigregister(newell)
class newell_constrained_timestep(newell):
    r"""
    Newell (2002) car-following model with timestep = 1.

    This class is based on the newell class, but the sole
    difference is that this class validates the timestep so it can
    only be 1
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Creates a Newell model manager with default values for the parameters.

        |

        *Overload 2:*
        Creates a Newell model manager with values for the parameters given in p.
               :type p: :py:class:`p_newell`
               :param p: A set of parameters for Newell's model.
        """
        _autopysta.newell_constrained_timestep_swiginit(self, _autopysta.new_newell_constrained_timestep(*args))

    def validate_parameters(self, *args):
        r"""
        Validate the model due to certain conditions the parameters have to meet.
               :type p: :py:class:`params`, optional
               :param p: Parameters for a car-following model.
        """
        return _autopysta.newell_constrained_timestep_validate_parameters(self, *args)

    def new_point(self, *args):
        r"""
        Get the next point with the possitions of the leader and the follower.
               :type leader: :py:class:`generalized_trajectory`
               :param leader: Generalized trajectory representing the leader's position and speed int time. Leave null for no leader.
               :type follower: :py:class:`trajectory`
               :param follower: Trajectory representing the follower's position and speed in time. Leave null for no follower.
               :type p: :py:class:`params`, optional
               :param p: Parameters for Newell's car-following model.

               :rtype: :py:class:`point`
               :return: Next point.
        """
        return _autopysta.newell_constrained_timestep_new_point(self, *args)
    __swig_destroy__ = _autopysta.delete_newell_constrained_timestep

# Register newell_constrained_timestep in _autopysta:
_autopysta.newell_constrained_timestep_swigregister(newell_constrained_timestep)
class newell_random_acceleration(newell):
    r"""
    Laval et al., 2014 car-following model, based on Newell (2002)

    Objects of this class manage the functionality related to
    vehicles' behavior according to the rules defined by Laval's
    car-following model, including values for the parameters.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Creates the model and initialize its parameters of the Newell model and also the new parameters of the Laval model, all with default parameters.

        |

        *Overload 2:*
        Creates the model and initialize its parameters of the Newell model and also the new parameters of the Laval model, with values for the parameters given in p
               :type p: :py:class:`p_newell_random_acceleration`
               :param p: A set of parameters for Newell's model.
        """
        _autopysta.newell_random_acceleration_swiginit(self, _autopysta.new_newell_random_acceleration(*args))

    def validate_parameters(self, *args):
        r"""
        Validate the model due to certain conditions the parameters have to meet.
               :type p: :py:class:`params`, optional
               :param p: Parameters for a car-following model.
        """
        return _autopysta.newell_random_acceleration_validate_parameters(self, *args)

    def new_point(self, *args):
        r"""
        Get the next point with the positions of the leader and the follower.
               :type leader: :py:class:`generalized_trajectory`
               :param leader: Generalized trajectory representing the leader's position and speed int time. Leave null for no leader.
               :type follower: :py:class:`trajectory`
               :param follower: Trajectory representing the follower's position and speed in time. Leave null for no follower.
               :type p: :py:class:`params`, optional
               :param p: Parameters for the model.

               :rtype: :py:class:`point`
               :return: Next point.
        """
        return _autopysta.newell_random_acceleration_new_point(self, *args)
    __swig_destroy__ = _autopysta.delete_newell_random_acceleration

# Register newell_random_acceleration in _autopysta:
_autopysta.newell_random_acceleration_swigregister(newell_random_acceleration)
class linear(model):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _autopysta.linear_swiginit(self, _autopysta.new_linear(*args))

    def equil_spcg(self, vl, vf, p):
        r"""
         Function description.
        		:type vl: float
        :param vl: First param description.
            		:type vf: float
        :param vf: Second param description.
            		:param q: Third param description.
        """
        return _autopysta.linear_equil_spcg(self, vl, vf, p)

    def wave_speed(self, leader, follower, p):
        r"""
         Function description.
        		:type leader: :py:class:`point`
        :param leader: First param description.
            		:type follower: :py:class:`point`
        :param follower: Second param description.
            		:param q: Third param description.
        """
        return _autopysta.linear_wave_speed(self, leader, follower, p)

    def free_flow_speed(self, *args):
        r"""
        Function description.
        	:param q: First param description.
        """
        return _autopysta.linear_free_flow_speed(self, *args)
    __swig_destroy__ = _autopysta.delete_linear

# Register linear in _autopysta:
_autopysta.linear_swigregister(linear)
class p_lcm_gipps(params):
    r"""
    Gipps (1986) lane-changing model's parameters.

    Objects of this class manage the parameters of Gipps's
    lane-changing model.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _pvl = property(_autopysta.p_lcm_gipps__pvl_get, _autopysta.p_lcm_gipps__pvl_set, doc=r""" _pvl double variable description.""")
    _pvh = property(_autopysta.p_lcm_gipps__pvh_get, _autopysta.p_lcm_gipps__pvh_set, doc=r""" _pvh double variable description.""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Creates a Gipps lane-changing model parameter's manager with default values for the parameters.

        |

        *Overload 2:*
        Creates a Gipps lane-changing model manager with values for the parameters given in p.
               :type pvlow: float
               :param pvlow: Fraction of the free-flow speed at which to overtake (change to the left lane).
               :type pvhigh: float
               :param pvhigh: Fraction of the free-flow speed at which to change back to the right lane
        """
        _autopysta.p_lcm_gipps_swiginit(self, _autopysta.new_p_lcm_gipps(*args))
    __swig_destroy__ = _autopysta.delete_p_lcm_gipps

# Register p_lcm_gipps in _autopysta:
_autopysta.p_lcm_gipps_swigregister(p_lcm_gipps)
class lcm_gipps(object):
    r"""
    Gipps (1986) lane-changing model.

    Objects of this class manage the functionality related to
    vehicles' behavior according to the rules defined by Gipps's
    lane-changing model, including values for the parameters.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Creates a Gipps lane-changing model manager with default values for the parameters.

        |

        *Overload 2:*
        Creates a Gipps lane-changing model manager with values for the parameters given in p.
               :type p: :py:class:`p_lcm_gipps`
               :param p: A set of parameters for Gipps lane-changing model.
        """
        _autopysta.lcm_gipps_swiginit(self, _autopysta.new_lcm_gipps(*args))

    def lch_left(self, leader, follower, new_leader, new_follower, cfm, lcmpars):
        r"""
        Returns true if the subject vehicle should change lanes to the left, according to the model.
               :type leader: :py:class:`point`
               :param leader: A point representing the leader's position and speed. Leave null for no leader.
               :type follower: :py:class:`point`
               :param follower: A point representing the subject vehicle's position and speed.
               :type new_leader: :py:class:`point`
               :param new_leader: A point representing the position and speed of the vehicle to become the subject's leader if the lane-changing maneuver is successful.
               :type new_follower: :py:class:`point`
               :param new_follower: A point representing the position and speed of the vehicle to become the subject's follower if the lane-changing maneuver is successful.
               :type cfm: :py:class:`model`
               :param cfm: A car-following model to compute speed and distance constraints.
               :type lcmpars: :py:class:`params`
               :param lcmpars: Parameters for Gipps car-following model.

               :rtype: boolean
               :return: Returns true if the lane-changing maneuver is feasible, and false otherwise.
        """
        return _autopysta.lcm_gipps_lch_left(self, leader, follower, new_leader, new_follower, cfm, lcmpars)

    def lch_right(self, leader, follower, new_leader, new_follower, cfm, lcmpars):
        r"""
        Returns true if the subject vehicle should change lanes to the right, according to the model.
               :type leader: :py:class:`point`
               :param leader: A point representing the leader's position and speed. Leave null for no leader.
               :type follower: :py:class:`point`
               :param follower: A point representing the subject vehicle's position and speed.
               :type new_leader: :py:class:`point`
               :param new_leader: A point representing the position and speed of the vehicle to become the subject's leader if the lane-changing maneuver is successful.
               :type new_follower: :py:class:`point`
               :param new_follower: A point representing the position and speed of the vehicle to become the subject's follower if the lane-changing maneuver is successful.
               :type cfm: :py:class:`model`
               :param cfm: A car-following model to compute speed and distance constraints.
               :type lcmpars: :py:class:`params`
               :param lcmpars: Parameters for Gipps car-following model.

               :rtype: boolean
               :return: Returns true if the lane-changing maneuver is feasible, and false otherwise.
        """
        return _autopysta.lcm_gipps_lch_right(self, leader, follower, new_leader, new_follower, cfm, lcmpars)
    __swig_destroy__ = _autopysta.delete_lcm_gipps

# Register lcm_gipps in _autopysta:
_autopysta.lcm_gipps_swigregister(lcm_gipps)
class no_lch(object):
    r"""
    Lane-changing model manager forbidding any lane-changes.

    An object of this class acts as a placeholder in the absense of
    a lane-changing model. It forbids any lane-changing maneuvers.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Creates a lane-changing model manager with default values for the parameters."""
        _autopysta.no_lch_swiginit(self, _autopysta.new_no_lch())

    def lch_left(self, leader, follower, new_leader, new_follower, cfm, lcmpars):
        r"""
        Always returns false since this model is intended to forbid lane-changing.
               :type leader: :py:class:`point`
               :param leader: A point representing the leader's position and speed. Leave null for no leader.
               :type follower: :py:class:`point`
               :param follower: A point representing the subject vehicle's position and speed.
               :type new_leader: :py:class:`point`
               :param new_leader: A point representing the position and speed of the vehicle to become the subject's leader if the lane-changing maneuver is successful.
               :type new_follower: :py:class:`point`
               :param new_follower: A point representing the position and speed of the vehicle to become the subject's follower if the lane-changing maneuver is successful.
               :type cfm: :py:class:`model`
               :param cfm: A car-following model to compute speed and distance constraints.
               :type lcmpars: :py:class:`params`
               :param lcmpars: Parameters for a car-following model.

               :rtype: boolean
               :return: Always returns false.
        """
        return _autopysta.no_lch_lch_left(self, leader, follower, new_leader, new_follower, cfm, lcmpars)

    def lch_right(self, leader, follower, new_leader, new_follower, cfm, lcmpars):
        r"""
        Always returns false since this model is intended to forbid lane-changing.
               :type leader: :py:class:`point`
               :param leader: A point representing the leader's position and speed. Leave null for no leader.
               :type follower: :py:class:`point`
               :param follower: A point representing the subject vehicle's position and speed.
               :type new_leader: :py:class:`point`
               :param new_leader: A point representing the position and speed of the vehicle to become the subject's leader if the lane-changing maneuver is successful.
               :type new_follower: :py:class:`point`
               :param new_follower: A point representing the position and speed of the vehicle to become the subject's follower if the lane-changing maneuver is successful.
               :type cfm: :py:class:`model`
               :param cfm: A car-following model to compute speed and distance constraints.
               :type lcmpars: :py:class:`params`
               :param lcmpars: Parameters for a car-following model.

               :rtype: boolean
               :return: Always returns false.
        """
        return _autopysta.no_lch_lch_right(self, leader, follower, new_leader, new_follower, cfm, lcmpars)
    __swig_destroy__ = _autopysta.delete_no_lch

# Register no_lch in _autopysta:
_autopysta.no_lch_swigregister(no_lch)
class geometry(object):
    r"""
    Geometry of the simulated highway segment

    Objects of this class manage details about the simulated highway segment's physical properties,
    such as length, number of lanes, presence of on/off ramps, etc.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Creates a geometry with the given physical properties.
        			:type _length: float
        :param _length: Length of the segment.
            			:type _lanes: int
        :param _lanes: Number of full-length lanes in the segment (on/off-ramps don't count).
            			:type _merge: float
        :param _merge: Position at which on-ramp ends (0 for no on-ramp).
            			:type _diverge: float
        :param _diverge: Position at which off-ramp starts (>= length for no off-ramp).


        |

        *Overload 2:*
         Creates a geometry with minimal physical properties.
        			:param _length: Length of the segment.
            			:param _lanes: Number of full-length lanes in the segment (on/off-ramps don't count).
        """
        _autopysta.geometry_swiginit(self, _autopysta.new_geometry(*args))

    def length(self):
        r"""
         Returns the length of the highway.
        			:rtype: float
        :return: Returns the length of the highway.
        """
        return _autopysta.geometry_length(self)

    def lanes(self):
        r"""
         Returns the ammount of lanes in the highway.
        			:rtype: int
        :return: Returns the ammount of lanes in the highway.
        """
        return _autopysta.geometry_lanes(self)

    def can_change_left(self, p):
        r"""
         Tells whether a lane-changing maneuver to the left is physically possible.
        			:type p: :py:class:`point`
        :param p: A point representing the position of the vehicle willing to change lanes.
        """
        return _autopysta.geometry_can_change_left(self, p)

    def can_change_right(self, p):
        r"""
         Tells whether a lane-changing maneuver to the right is physically possible.
        			:type p: :py:class:`point`
        :param p: A point representing the position of the vehicle willing to change lanes.
        """
        return _autopysta.geometry_can_change_right(self, p)

    def has_merge(self):
        r"""
         Returns true if the segment has an on-ramp.
        			:rtype: boolean
        :return: Returns a boolean.
        """
        return _autopysta.geometry_has_merge(self)

    def merge(self):
        r"""
         Returns the position at which the merge ends.
        			:rtype: float
        :return: Returns a double.
        """
        return _autopysta.geometry_merge(self)

    def has_diverge(self):
        r"""
         Returns true if the segment has an off-ramp.
        			:rtype: boolean
        :return: Returns a boolean.
        """
        return _autopysta.geometry_has_diverge(self)
    __swig_destroy__ = _autopysta.delete_geometry

# Register geometry in _autopysta:
_autopysta.geometry_swigregister(geometry)
class creator(object):
    r"""
    Brief description about creator class.

    More details about creator class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def validate_creator(self):
        return _autopysta.creator_validate_creator(self)

    def create(self, leader, immediate_follower=False):
        r"""
        		Checks whether to create a vehicle and creates it if appropriate.
        		If true then the vehicle will be placed just behind the leader's point,
        		if false then it will be placed at the beggining of the lane.

        		:type leader: :py:class:`point`
        :param leader: The current point of the leader.
            		:type immediate_follower: boolean, optional
        :param immediate_follower: Boolean that indicates if the new vehicle is just behind the leader.

        		:rtype: :py:class:`vehicle`
        :return: Returns the new vehicle if created, null otherwise.
        """
        return _autopysta.creator_create(self, leader, immediate_follower)

    def create_no_leader(self, lane):
        r"""
         Checks whether to create a vehicle in an empty lane and creates it if appropriate.
        		:type lane: int
        :param lane: Lane number.

        		:rtype: :py:class:`vehicle`
        :return: Returns the new vehicle if created, null otherwise.
        """
        return _autopysta.creator_create_no_leader(self, lane)

    def initial_state(self, leader):
        r"""
         Creates the vehicles present in the first simulation timestep in the lane.
        		:type leader: :py:class:`point`
        :param leader: A manually-created leading vehicle.
        """
        return _autopysta.creator_initial_state(self, leader)
    __swig_destroy__ = _autopysta.delete_creator

# Register creator in _autopysta:
_autopysta.creator_swigregister(creator)
class creator_martinez_jin_2020(creator):
    r"""
    Vehicle creator injecting vehicles with the Martinez and Jin model with a fixed state and random jam density.

    Objects of this class create vehicles with a given spacing and
    speed, and place them at the beginning of a lane, unless the lane's
    capacity or other vehicles put additional constraints.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    a = property(_autopysta.creator_martinez_jin_2020_a_get, _autopysta.creator_martinez_jin_2020_a_set, doc=r""" Minimum of uniform distribution.""")
    b = property(_autopysta.creator_martinez_jin_2020_b_get, _autopysta.creator_martinez_jin_2020_b_set, doc=r""" Maximum of uniform distribution.""")

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Creates a fixed-state creator.
        		:param _model: A car-following model governing the lane's capacity.
            		:type _spacing: float
        :param _spacing: The creators target spacing.
            		:type _initial_speed: float
        :param _initial_speed: Initial speed for each new car created.


        |

        *Overload 2:*
         Creates a fixed-state creator.
        		:param _model: A car-following model governing the lane's capacity.
            		:type _spacing: float
        :param _spacing: The creators target spacing.
            		:type _initial_speed: float
        :param _initial_speed: Initial speed for each new car created.


        |

        *Overload 3:*
         Creates a fixed-state creator.
        		:param _model: A car-following model governing the lane's capacity.
            		:type _spacing: float
        :param _spacing: The creators target spacing.
            		:type _initial_speed: float
        :param _initial_speed: Initial speed for each new car created.
            		:type maxvehs: int
        :param maxvehs: Maximum ammount of vehicles to be created.


        |

        *Overload 4:*
         Creates a fixed-state creator.
        		:param _model: A car-following model governing the lane's capacity.
            		:type _spacing: float
        :param _spacing: The creators target spacing.
            		:type _initial_speed: float
        :param _initial_speed: Initial speed for each new car created.
        """
        _autopysta.creator_martinez_jin_2020_swiginit(self, _autopysta.new_creator_martinez_jin_2020(*args))

    def create(self, leader, immediate_follower=False):
        r"""
                Checks whether to create a vehicle and creates it if appropriate.
        		If true then the vehicle will be placed just behind the leader's
                point, if false then it will be placed at the beggining of the lane.
                The diference with the base creator is that the vehicles will be created
                with a random jam density.

        		:type leader: :py:class:`point`
        :param leader: The current point of the leader.
            		:type immediate_follower: boolean, optional
        :param immediate_follower: Boolean that indicates if the new vehicle is just behind the leader.

        		:rtype: :py:class:`vehicle`
        :return: Returns the new vehicle if created, null otherwise.
        """
        return _autopysta.creator_martinez_jin_2020_create(self, leader, immediate_follower)

    def create_no_leader(self, lane):
        r"""
         Checks whether to create a vehicle in an empty lane and creates it if appropriate.
        		:type lane: int
        :param lane: Lane number.

        		:rtype: :py:class:`vehicle`
        :return: Returns the new vehicle if created, null otherwise.
        """
        return _autopysta.creator_martinez_jin_2020_create_no_leader(self, lane)

    def validate_creator(self):
        return _autopysta.creator_martinez_jin_2020_validate_creator(self)
    __swig_destroy__ = _autopysta.delete_creator_martinez_jin_2020

# Register creator_martinez_jin_2020 in _autopysta:
_autopysta.creator_martinez_jin_2020_swigregister(creator_martinez_jin_2020)
class fixed_state_creator(creator):
    r"""
    Vehicle creator injecting vehicles with a fixed state.

    Objects of this class create vehicles with a given spacing and
    speed, and place them at the beginning of a lane, unless the lane's
    capacity or other vehicles put additional constraints.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def validate_creator(self):
        r"""
        Checks if demand is feasible.
        	Validates if the demand (flow) set is feasible according to the dt of the simulation.
        	If it is not valid, then an error will be thrown.
        """
        return _autopysta.fixed_state_creator_validate_creator(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Creates a fixed-state creator.
        		:type _model: :py:class:`model`
        :param _model: A car-following model governing the lane's capacity.
            		:type _spacing: float
        :param _spacing: The creators target spacing.
            		:type _initial_speed: float
        :param _initial_speed: Initial speed for each new car created.
            		:type maxvehs: int
        :param maxvehs: Maximum ammount of vehicles to be created.


        |

        *Overload 2:*
         Creates a fixed-state creator.
        		:type _model: :py:class:`model`
        :param _model: A car-following model governing the lane's capacity.
            		:type _spacing: float
        :param _spacing: The creators target spacing.
            		:type _initial_speed: float
        :param _initial_speed: Initial speed for each new car created.
        """
        _autopysta.fixed_state_creator_swiginit(self, _autopysta.new_fixed_state_creator(*args))

    def create_no_leader(self, lane):
        r"""
         Checks whether to create a vehicle in an empty lane and creates it if appropriate.
        		:type lane: int
        :param lane: Lane number.

        		:rtype: :py:class:`vehicle`
        :return: Returns the new vehicle if created, null otherwise.
        """
        return _autopysta.fixed_state_creator_create_no_leader(self, lane)
    __swig_destroy__ = _autopysta.delete_fixed_state_creator

# Register fixed_state_creator in _autopysta:
_autopysta.fixed_state_creator_swigregister(fixed_state_creator)
class fixed_demand_creator(creator):
    r"""
    Vehicle creator injecting vehicles at a fixed rate.

    Objects of this class create vehicles at a given rate and
    place them at the beginning of a lane, unless the lane's
    capacity or other vehicles do not allow it.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Creates a fixed-demand vehicle creator.
        		:type _model: :py:class:`model`
        :param _model: A car-following model governing the lane's capacity.
            		:type _flow: float
        :param _flow: The creator's target demand.


        |

        *Overload 2:*
         Creates a limited fixed-demand creator.
        		:type _model: :py:class:`model`
        :param _model: A car-following model governing the lane's capacity.
            		:type _flow: float
        :param _flow: The creator's target demand.
            		:type maxvehs: int
        :param maxvehs: The total number of vehicles to create.
        """
        _autopysta.fixed_demand_creator_swiginit(self, _autopysta.new_fixed_demand_creator(*args))

    def validate_creator(self):
        r"""
        Checks if demand is feasible.
        	Validates if the demand (flow) set is feasible according to the dt of the simulation.
        	If it is not valid, then an error will be thrown.
        """
        return _autopysta.fixed_demand_creator_validate_creator(self)

    def create_no_leader(self, lane):
        r"""
         Checks whether to create a vehicle in an empty lane and creates it if appropriate.
        		:type lane: int
        :param lane: Lane number.

        		:rtype: :py:class:`vehicle`
        :return: Returns the new vehicle if created, null otherwise.
        """
        return _autopysta.fixed_demand_creator_create_no_leader(self, lane)
    __swig_destroy__ = _autopysta.delete_fixed_demand_creator

# Register fixed_demand_creator in _autopysta:
_autopysta.fixed_demand_creator_swigregister(fixed_demand_creator)
class results(object):
    r"""Results class (some description) for storing and displaying the values"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, r):
        r"""
        Constructor. Take the results of the simulation.
               :type r: std::vector< trajectory * >
               :param r: Simulation results. Trajectory of all cars.
        """
        _autopysta.results_swiginit(self, _autopysta.new_results(r))

    def porpista(self, c):
        r"""
        Split a car trajectory by lanes.
               :type c: int
               :param c: Car trajectory to be splitted by lanes.
        """
        return _autopysta.results_porpista(self, c)

    def by_lane(self, l):
        r"""
        Get trajectories by lane.
               :type l: int
               :param l: Lane selected.
        """
        return _autopysta.results_by_lane(self, l)

    def all_lanes(self):
        r""" Get trajectories of all lanes."""
        return _autopysta.results_all_lanes(self)

    def edie(self, ta, tb, dt, xa, xb, l):
        r"""
        Compute Edie's flow and density for a given period of time and distance
               :type ta: float
               :param ta: Starting time.
               :type tb: float
               :param tb: Ending time.
               :type dt: float
               :param dt: Time step size.
               :type xa: float
               :param xa: Starting distance.
               :type xb: float
               :param xb: Ending distance.
               :type l: int
               :param l: Lane selected.
        """
        return _autopysta.results_edie(self, ta, tb, dt, xa, xb, l)

    def passes_on_t(self, t, l):
        r"""
        Get list of cars' points in a certain time t and lane l
               :type t: float
               :param t: Time
               :type l: int
               :param l: Lane

               :rtype: std::vector< point * >
               :return: List of cars in the lane l by the time t.
        """
        return _autopysta.results_passes_on_t(self, t, l)

    def passes_on_x(self, x, l):
        r"""
        Get list of cars' points in a certain distance x and lane l
               :type x: float
               :param x: Distance
               :type l: int
               :param l: Lane

               :rtype: std::vector< point * >
               :return: List of cars in the lane l by the distance x.
        """
        return _autopysta.results_passes_on_x(self, x, l)
    __swig_destroy__ = _autopysta.delete_results

# Register results in _autopysta:
_autopysta.results_swigregister(results)
class Box(object):
    r"""
    Defines the time and space limits to measure Edie's values
       L
        ^
        | :    :
    x_b-|-+----+--
        | :    :
    x_a-|-+----+--
        | :    :
        |_:____:___>
          :    :    t
         t_a  t_b
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    trails = property(_autopysta.Box_trails_get, _autopysta.Box_trails_set, doc=r""" Starting and enging points of the trajectories that cross the box""")

    def __init__(self, xa, xb, ta, tb):
        r"""
        Define a box in time and space.
               :type xa: float
               :param xa: Starting point for distance
               :type xb: float
               :param xb: Ending point for distance
               :type ta: float
               :param ta: Starting point for time
               :type tb: float
               :param tb: Ending point for time
        """
        _autopysta.Box_swiginit(self, _autopysta.new_Box(xa, xb, ta, tb))

    def contains(self, p):
        r"""
        Checks if a point is in the box, including the edges
               :type p: :py:class:`point`
               :param p: Point to be checked
               :param exclusive: True if the borders shouldn't count as part of the box.

               :rtype: boolean
               :return: True if the point is in the box, false otherwise
        """
        return _autopysta.Box_contains(self, p)

    def get_intersection(self, p1, p2):
        r"""
        Gets the intersecting point from two points and the box
               :type p1: :py:class:`point`
               :param p1: Firts point of the line
               :type p2: :py:class:`point`
               :param p2: Second point of the line

               :rtype: :py:class:`point`
               :return: The point in the box edge and betwen the two points
        """
        return _autopysta.Box_get_intersection(self, p1, p2)

    def inter_hor(self, p1, p2, x):
        return _autopysta.Box_inter_hor(self, p1, p2, x)

    def inter_ver(self, p1, p2, t):
        return _autopysta.Box_inter_ver(self, p1, p2, t)

    def get_edie(self):
        r"""
        Computes the Edie values for this box
               :rtype: std::vector< double >
               :return: A vector<double> where [Q: D* / A, K: T* / A].
        """
        return _autopysta.Box_get_edie(self)

    def _print(self):
        return _autopysta.Box__print(self)
    __swig_destroy__ = _autopysta.delete_Box

# Register Box in _autopysta:
_autopysta.Box_swigregister(Box)
class Exception(object):
    r"""
    Exception class for handling error's

    Used internally in source files.
    Can be catched in python by using

    .. code-block:: c++

       		import autpysta as ap

       		try:
       			[...]
       		except ap.Exception, e:
       			print (e.msg)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, c, m):
        r"""
        Exception constructor.
               :type c: int
               :param c: Error code.
               :type m: string
               :param m: Error message.
        """
        _autopysta.Exception_swiginit(self, _autopysta.new_Exception(c, m))

    def code(self):
        r""" Returns the error code."""
        return _autopysta.Exception_code(self)

    def msg(self):
        r""" Returns the error message."""
        return _autopysta.Exception_msg(self)

    def what(self):
        r""" Returns the error message with an exception specification."""
        return _autopysta.Exception_what(self)
    __swig_destroy__ = _autopysta.delete_Exception
    _code = property(_autopysta.Exception__code_get, _autopysta.Exception__code_set, doc=r""" Error code.""")
    _msg = property(_autopysta.Exception__msg_get, _autopysta.Exception__msg_set, doc=r""" Error message.""")

# Register Exception in _autopysta:
_autopysta.Exception_swigregister(Exception)
class trajectories(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _autopysta.trajectories_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _autopysta.trajectories___nonzero__(self)

    def __bool__(self):
        return _autopysta.trajectories___bool__(self)

    def __len__(self):
        return _autopysta.trajectories___len__(self)

    def __getslice__(self, i, j):
        return _autopysta.trajectories___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _autopysta.trajectories___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _autopysta.trajectories___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _autopysta.trajectories___delitem__(self, *args)

    def __getitem__(self, *args):
        return _autopysta.trajectories___getitem__(self, *args)

    def __setitem__(self, *args):
        return _autopysta.trajectories___setitem__(self, *args)

    def pop(self):
        return _autopysta.trajectories_pop(self)

    def append(self, x):
        return _autopysta.trajectories_append(self, x)

    def empty(self):
        return _autopysta.trajectories_empty(self)

    def size(self):
        return _autopysta.trajectories_size(self)

    def swap(self, v):
        return _autopysta.trajectories_swap(self, v)

    def begin(self):
        return _autopysta.trajectories_begin(self)

    def end(self):
        return _autopysta.trajectories_end(self)

    def rbegin(self):
        return _autopysta.trajectories_rbegin(self)

    def rend(self):
        return _autopysta.trajectories_rend(self)

    def clear(self):
        return _autopysta.trajectories_clear(self)

    def get_allocator(self):
        return _autopysta.trajectories_get_allocator(self)

    def pop_back(self):
        return _autopysta.trajectories_pop_back(self)

    def erase(self, *args):
        return _autopysta.trajectories_erase(self, *args)

    def __init__(self, *args):
        _autopysta.trajectories_swiginit(self, _autopysta.new_trajectories(*args))

    def push_back(self, x):
        return _autopysta.trajectories_push_back(self, x)

    def front(self):
        return _autopysta.trajectories_front(self)

    def back(self):
        return _autopysta.trajectories_back(self)

    def assign(self, n, x):
        return _autopysta.trajectories_assign(self, n, x)

    def resize(self, *args):
        return _autopysta.trajectories_resize(self, *args)

    def insert(self, *args):
        return _autopysta.trajectories_insert(self, *args)

    def reserve(self, n):
        return _autopysta.trajectories_reserve(self, n)

    def capacity(self):
        return _autopysta.trajectories_capacity(self)
    __swig_destroy__ = _autopysta.delete_trajectories

# Register trajectories in _autopysta:
_autopysta.trajectories_swigregister(trajectories)
class vehvec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _autopysta.vehvec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _autopysta.vehvec___nonzero__(self)

    def __bool__(self):
        return _autopysta.vehvec___bool__(self)

    def __len__(self):
        return _autopysta.vehvec___len__(self)

    def __getslice__(self, i, j):
        return _autopysta.vehvec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _autopysta.vehvec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _autopysta.vehvec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _autopysta.vehvec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _autopysta.vehvec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _autopysta.vehvec___setitem__(self, *args)

    def pop(self):
        return _autopysta.vehvec_pop(self)

    def append(self, x):
        return _autopysta.vehvec_append(self, x)

    def empty(self):
        return _autopysta.vehvec_empty(self)

    def size(self):
        return _autopysta.vehvec_size(self)

    def swap(self, v):
        return _autopysta.vehvec_swap(self, v)

    def begin(self):
        return _autopysta.vehvec_begin(self)

    def end(self):
        return _autopysta.vehvec_end(self)

    def rbegin(self):
        return _autopysta.vehvec_rbegin(self)

    def rend(self):
        return _autopysta.vehvec_rend(self)

    def clear(self):
        return _autopysta.vehvec_clear(self)

    def get_allocator(self):
        return _autopysta.vehvec_get_allocator(self)

    def pop_back(self):
        return _autopysta.vehvec_pop_back(self)

    def erase(self, *args):
        return _autopysta.vehvec_erase(self, *args)

    def __init__(self, *args):
        _autopysta.vehvec_swiginit(self, _autopysta.new_vehvec(*args))

    def push_back(self, x):
        return _autopysta.vehvec_push_back(self, x)

    def front(self):
        return _autopysta.vehvec_front(self)

    def back(self):
        return _autopysta.vehvec_back(self)

    def assign(self, n, x):
        return _autopysta.vehvec_assign(self, n, x)

    def resize(self, *args):
        return _autopysta.vehvec_resize(self, *args)

    def insert(self, *args):
        return _autopysta.vehvec_insert(self, *args)

    def reserve(self, n):
        return _autopysta.vehvec_reserve(self, n)

    def capacity(self):
        return _autopysta.vehvec_capacity(self)
    __swig_destroy__ = _autopysta.delete_vehvec

# Register vehvec in _autopysta:
_autopysta.vehvec_swigregister(vehvec)
class crtvec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _autopysta.crtvec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _autopysta.crtvec___nonzero__(self)

    def __bool__(self):
        return _autopysta.crtvec___bool__(self)

    def __len__(self):
        return _autopysta.crtvec___len__(self)

    def __getslice__(self, i, j):
        return _autopysta.crtvec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _autopysta.crtvec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _autopysta.crtvec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _autopysta.crtvec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _autopysta.crtvec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _autopysta.crtvec___setitem__(self, *args)

    def pop(self):
        return _autopysta.crtvec_pop(self)

    def append(self, x):
        return _autopysta.crtvec_append(self, x)

    def empty(self):
        return _autopysta.crtvec_empty(self)

    def size(self):
        return _autopysta.crtvec_size(self)

    def swap(self, v):
        return _autopysta.crtvec_swap(self, v)

    def begin(self):
        return _autopysta.crtvec_begin(self)

    def end(self):
        return _autopysta.crtvec_end(self)

    def rbegin(self):
        return _autopysta.crtvec_rbegin(self)

    def rend(self):
        return _autopysta.crtvec_rend(self)

    def clear(self):
        return _autopysta.crtvec_clear(self)

    def get_allocator(self):
        return _autopysta.crtvec_get_allocator(self)

    def pop_back(self):
        return _autopysta.crtvec_pop_back(self)

    def erase(self, *args):
        return _autopysta.crtvec_erase(self, *args)

    def __init__(self, *args):
        _autopysta.crtvec_swiginit(self, _autopysta.new_crtvec(*args))

    def push_back(self, x):
        return _autopysta.crtvec_push_back(self, x)

    def front(self):
        return _autopysta.crtvec_front(self)

    def back(self):
        return _autopysta.crtvec_back(self)

    def assign(self, n, x):
        return _autopysta.crtvec_assign(self, n, x)

    def resize(self, *args):
        return _autopysta.crtvec_resize(self, *args)

    def insert(self, *args):
        return _autopysta.crtvec_insert(self, *args)

    def reserve(self, n):
        return _autopysta.crtvec_reserve(self, n)

    def capacity(self):
        return _autopysta.crtvec_capacity(self)
    __swig_destroy__ = _autopysta.delete_crtvec

# Register crtvec in _autopysta:
_autopysta.crtvec_swigregister(crtvec)
class pntvec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _autopysta.pntvec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _autopysta.pntvec___nonzero__(self)

    def __bool__(self):
        return _autopysta.pntvec___bool__(self)

    def __len__(self):
        return _autopysta.pntvec___len__(self)

    def __getslice__(self, i, j):
        return _autopysta.pntvec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _autopysta.pntvec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _autopysta.pntvec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _autopysta.pntvec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _autopysta.pntvec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _autopysta.pntvec___setitem__(self, *args)

    def pop(self):
        return _autopysta.pntvec_pop(self)

    def append(self, x):
        return _autopysta.pntvec_append(self, x)

    def empty(self):
        return _autopysta.pntvec_empty(self)

    def size(self):
        return _autopysta.pntvec_size(self)

    def swap(self, v):
        return _autopysta.pntvec_swap(self, v)

    def begin(self):
        return _autopysta.pntvec_begin(self)

    def end(self):
        return _autopysta.pntvec_end(self)

    def rbegin(self):
        return _autopysta.pntvec_rbegin(self)

    def rend(self):
        return _autopysta.pntvec_rend(self)

    def clear(self):
        return _autopysta.pntvec_clear(self)

    def get_allocator(self):
        return _autopysta.pntvec_get_allocator(self)

    def pop_back(self):
        return _autopysta.pntvec_pop_back(self)

    def erase(self, *args):
        return _autopysta.pntvec_erase(self, *args)

    def __init__(self, *args):
        _autopysta.pntvec_swiginit(self, _autopysta.new_pntvec(*args))

    def push_back(self, x):
        return _autopysta.pntvec_push_back(self, x)

    def front(self):
        return _autopysta.pntvec_front(self)

    def back(self):
        return _autopysta.pntvec_back(self)

    def assign(self, n, x):
        return _autopysta.pntvec_assign(self, n, x)

    def resize(self, *args):
        return _autopysta.pntvec_resize(self, *args)

    def insert(self, *args):
        return _autopysta.pntvec_insert(self, *args)

    def reserve(self, n):
        return _autopysta.pntvec_reserve(self, n)

    def capacity(self):
        return _autopysta.pntvec_capacity(self)
    __swig_destroy__ = _autopysta.delete_pntvec

# Register pntvec in _autopysta:
_autopysta.pntvec_swigregister(pntvec)
class fltvec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _autopysta.fltvec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _autopysta.fltvec___nonzero__(self)

    def __bool__(self):
        return _autopysta.fltvec___bool__(self)

    def __len__(self):
        return _autopysta.fltvec___len__(self)

    def __getslice__(self, i, j):
        return _autopysta.fltvec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _autopysta.fltvec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _autopysta.fltvec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _autopysta.fltvec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _autopysta.fltvec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _autopysta.fltvec___setitem__(self, *args)

    def pop(self):
        return _autopysta.fltvec_pop(self)

    def append(self, x):
        return _autopysta.fltvec_append(self, x)

    def empty(self):
        return _autopysta.fltvec_empty(self)

    def size(self):
        return _autopysta.fltvec_size(self)

    def swap(self, v):
        return _autopysta.fltvec_swap(self, v)

    def begin(self):
        return _autopysta.fltvec_begin(self)

    def end(self):
        return _autopysta.fltvec_end(self)

    def rbegin(self):
        return _autopysta.fltvec_rbegin(self)

    def rend(self):
        return _autopysta.fltvec_rend(self)

    def clear(self):
        return _autopysta.fltvec_clear(self)

    def get_allocator(self):
        return _autopysta.fltvec_get_allocator(self)

    def pop_back(self):
        return _autopysta.fltvec_pop_back(self)

    def erase(self, *args):
        return _autopysta.fltvec_erase(self, *args)

    def __init__(self, *args):
        _autopysta.fltvec_swiginit(self, _autopysta.new_fltvec(*args))

    def push_back(self, x):
        return _autopysta.fltvec_push_back(self, x)

    def front(self):
        return _autopysta.fltvec_front(self)

    def back(self):
        return _autopysta.fltvec_back(self)

    def assign(self, n, x):
        return _autopysta.fltvec_assign(self, n, x)

    def resize(self, *args):
        return _autopysta.fltvec_resize(self, *args)

    def insert(self, *args):
        return _autopysta.fltvec_insert(self, *args)

    def reserve(self, n):
        return _autopysta.fltvec_reserve(self, n)

    def capacity(self):
        return _autopysta.fltvec_capacity(self)
    __swig_destroy__ = _autopysta.delete_fltvec

# Register fltvec in _autopysta:
_autopysta.fltvec_swigregister(fltvec)
class fltvecvec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _autopysta.fltvecvec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _autopysta.fltvecvec___nonzero__(self)

    def __bool__(self):
        return _autopysta.fltvecvec___bool__(self)

    def __len__(self):
        return _autopysta.fltvecvec___len__(self)

    def __getslice__(self, i, j):
        return _autopysta.fltvecvec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _autopysta.fltvecvec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _autopysta.fltvecvec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _autopysta.fltvecvec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _autopysta.fltvecvec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _autopysta.fltvecvec___setitem__(self, *args)

    def pop(self):
        return _autopysta.fltvecvec_pop(self)

    def append(self, x):
        return _autopysta.fltvecvec_append(self, x)

    def empty(self):
        return _autopysta.fltvecvec_empty(self)

    def size(self):
        return _autopysta.fltvecvec_size(self)

    def swap(self, v):
        return _autopysta.fltvecvec_swap(self, v)

    def begin(self):
        return _autopysta.fltvecvec_begin(self)

    def end(self):
        return _autopysta.fltvecvec_end(self)

    def rbegin(self):
        return _autopysta.fltvecvec_rbegin(self)

    def rend(self):
        return _autopysta.fltvecvec_rend(self)

    def clear(self):
        return _autopysta.fltvecvec_clear(self)

    def get_allocator(self):
        return _autopysta.fltvecvec_get_allocator(self)

    def pop_back(self):
        return _autopysta.fltvecvec_pop_back(self)

    def erase(self, *args):
        return _autopysta.fltvecvec_erase(self, *args)

    def __init__(self, *args):
        _autopysta.fltvecvec_swiginit(self, _autopysta.new_fltvecvec(*args))

    def push_back(self, x):
        return _autopysta.fltvecvec_push_back(self, x)

    def front(self):
        return _autopysta.fltvecvec_front(self)

    def back(self):
        return _autopysta.fltvecvec_back(self)

    def assign(self, n, x):
        return _autopysta.fltvecvec_assign(self, n, x)

    def resize(self, *args):
        return _autopysta.fltvecvec_resize(self, *args)

    def insert(self, *args):
        return _autopysta.fltvecvec_insert(self, *args)

    def reserve(self, n):
        return _autopysta.fltvecvec_reserve(self, n)

    def capacity(self):
        return _autopysta.fltvecvec_capacity(self)
    __swig_destroy__ = _autopysta.delete_fltvecvec

# Register fltvecvec in _autopysta:
_autopysta.fltvecvec_swigregister(fltvecvec)
class road_object(object):
    r"""
    Brief description about road_object class.

    More details about road_object class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    m = property(_autopysta.road_object_m_get, _autopysta.road_object_m_set, doc=r""" m description.""")
    traj = property(_autopysta.road_object_traj_get, _autopysta.road_object_traj_set, doc=r""" Object trajectory, to be defined by the model.""")
    defined_t = property(_autopysta.road_object_defined_t_get, _autopysta.road_object_defined_t_set, doc=r""" Object defined trajectory if the user gives any that in each dt will give the front point to traj.""")

    def current(self):
        r"""
         Function description.
        		:rtype: :py:class:`point`
        :return: Returns a point.
        """
        return _autopysta.road_object_current(self)

    def update(self, arg2):
        r"""
        Function description.
        	:param Takes: a pointer to a road_object.
        """
        return _autopysta.road_object_update(self, arg2)
    __swig_destroy__ = _autopysta.delete_road_object

# Register road_object in _autopysta:
_autopysta.road_object_swigregister(road_object)
class vehicle(road_object):
    r"""
    Brief description about vehicle class.

    More details about vehicle class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    needs_initialization = property(_autopysta.vehicle_needs_initialization_get, _autopysta.vehicle_needs_initialization_set, doc=r""" Boolean that indicates if a vehicle with a given trajectory need to initialize its points inside the simulation""")
    placeholder_points = property(_autopysta.vehicle_placeholder_points_get, _autopysta.vehicle_placeholder_points_set)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Create a new vehicle.
        		Vehicle with defined trajectory for each X, only on one lane,
        		assuming that every point is at the exact same distance in time, equivalent to dt.
        		:type x: std::vector< double >
        :param x: List of x positions of the vehicle over time.
            		:type l: int
        :param l: Lane on which the vehicle moves.


        |

        *Overload 2:*
         Create a new vehicle.
        		Vehicle with defined trajectory for each X, with multiple lanes,
        		assuming that every point is at the exact same distance in time, equivalent to dt.
        		:type x: std::vector< double >
        :param x: List of x positions of the vehicle over time.
            		:type l: std::vector< int >
        :param l: List of lane positions of the vehicle over time.


        |

        *Overload 3:*
         Create a new vehicle.
        		Vehicle with defined trajectory as points
        		:type p: std::vector< point * >
        :param p: Position of the vehicle in time. Includes distance and lane.


        |

        *Overload 4:*
         Create a new vehicle.
        		Vehicle with a model, initial position, initial speed and lane.
        		:type m: :py:class:`model`
        :param m: Model to describe the vehicle behaviour.
            		:type x: float
        :param x: Initial position of the vehicle.
            		:type v: float
        :param v: Initial speed of the vehicle.
            		:type l: int
        :param l: Initial lane of the vehicle.


        |

        *Overload 5:*
         Create a new vehicle.
        		Vehicle with a model and a starting point.
        		:type m: :py:class:`model`
        :param m: Model to describe the vehicle behaviour.
            		:type p: :py:class:`point`
        :param p: Starting point.
        """
        _autopysta.vehicle_swiginit(self, _autopysta.new_vehicle(*args))

    def initialize_vehicle(self):
        r"""
        Function description.
        	Initialize the defined_t's placeholder points of a vehicle with a given trajectory with real points.
        """
        return _autopysta.vehicle_initialize_vehicle(self)

    def p(self):
        r""" Function description."""
        return _autopysta.vehicle_p(self)

    def current(self):
        r""" Function description"""
        return _autopysta.vehicle_current(self)

    def update(self, arg2):
        r""" Function description."""
        return _autopysta.vehicle_update(self, arg2)
    __swig_destroy__ = _autopysta.delete_vehicle

# Register vehicle in _autopysta:
_autopysta.vehicle_swigregister(vehicle)
class fixed_object(road_object):
    r"""
    Brief description about fixed_object class.

    More details about fixed_object class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pos):
        r"""
         Function description.
        		:type pos: :py:class:`point`
        :param pos: Position of the object.
        """
        _autopysta.fixed_object_swiginit(self, _autopysta.new_fixed_object(pos))

    def current(self):
        r"""
         Function description.
        		:rtype: :py:class:`point`
        :return: Position of the object
        """
        return _autopysta.fixed_object_current(self)

    def update(self, ro):
        r"""
         Function description.
        		:type ro: :py:class:`road_object`
        :param ro: Road object.
        """
        return _autopysta.fixed_object_update(self, ro)
    __swig_destroy__ = _autopysta.delete_fixed_object

# Register fixed_object in _autopysta:
_autopysta.fixed_object_swigregister(fixed_object)
class simulation(object):
    r"""
    Brief description about simulation class.

    More details about simulation class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Simulation constructor.
        		:type d: lcm
        :param d: Lane-changing model.
            		:type T: float
        :param T: Total simulation time.
            		:type g: :py:class:`geometry`
        :param g: Highway segment's geometry.
            		:type c: :py:class:`creator`
        :param c: A common vehicle creator for all lanes.
            		:param dt: Simulation timestep.


        |

        *Overload 2:*
         2nd simulation constructor.
        		:type d: lcm
        :param d: Lane-changing model.
            		:type T: float
        :param T: Total simulation time.
            		:type g: :py:class:`geometry`
        :param g: Highway segment's geometry.
            		:type creators: std::vector< creator * >
        :param creators: A list of vehicle creators, one for each lane.
            		:type veh: :py:class:`vehicle`
        :param veh: A pre-existing vehicle.
            		:type dt: float
        :param dt: Simulation timestep.


        |

        *Overload 3:*
         3rd simulation constructor.
        		:type d: lcm
        :param d: Lane-changing model.
            		:type T: float
        :param T: Total simulation time.
            		:type g: :py:class:`geometry`
        :param g: Highway segment's geometry.
            		:type creators: std::vector< creator * >
        :param creators: A list of vehicle creators, one for each lane.
            		:type vehs: std::vector< vehicle * >
        :param vehs: A list of pre-existing vehicles.
            		:type dt: float
        :param dt: Simulation timestep.
        """
        _autopysta.simulation_swiginit(self, _autopysta.new_simulation(*args))

    def run(self):
        r"""
         Run the simulation.
        		:rtype: :py:class:`results`
        :return: An object describing the simulation results.
        """
        return _autopysta.simulation_run(self)
    __swig_destroy__ = _autopysta.delete_simulation

# Register simulation in _autopysta:
_autopysta.simulation_swigregister(simulation)

def is_python_builtin():
    return _autopysta.is_python_builtin()

def _autopysta_graph_trajectories(self, lane=-1):
	colors = ['g-', 'r-', 'b-', 'k-', 'c-', 'm-', 'y-']
	pt.figure()
	if(lane == -1):
		trys = self.all_lanes()
		pt.title("All lanes")
	else:
		trys = self.by_lane(lane)
		pt.title("Lane {0}".format(lane))
	pt.xlabel("Time (seconds)")
	pt.ylabel("Position (meters)")
	for pi in range(len(trys)):
		pd = trys[pi]
		p=pd[0].LANE()
		tt=[pd[i].T() for i in range(len(pd))]
		xx=[pd[i].X() for i in range(len(pd))]
		pt.plot(tt,xx,colors[p])
	pt.show()

def _autopysta_graph_velocities(self, lane=-1):
	colors = ['g-', 'r-', 'b-', 'k-', 'c-', 'm-', 'y-']
	pt.figure()
	if(lane == -1):
		trys = self.all_lanes()
		pt.title("All lanes")
	else:
		trys = self.by_lane(lane)
		pt.title("Lane {0}".format(lane))
	pt.xlabel("Time (seconds)")
	pt.ylabel("Velocity (m/s)")
	for pi in range(len(trys)):
		pd = trys[pi]
		p=pd[0].LANE()
		tt=[pd[i].T() for i in range(len(pd))]
		xx=[pd[i].V() for i in range(len(pd))]
		pt.plot(tt,xx,colors[p])
	pt.show()

results.plot_x_vs_t = _autopysta_graph_trajectories
results.plot_v_vs_t = _autopysta_graph_velocities

class AutopystaException(BaseException):
    def __init__(self):
        BaseException.__init__(self)
        self.myexc = Exception()

AutopystaException = _autopysta.Exception


