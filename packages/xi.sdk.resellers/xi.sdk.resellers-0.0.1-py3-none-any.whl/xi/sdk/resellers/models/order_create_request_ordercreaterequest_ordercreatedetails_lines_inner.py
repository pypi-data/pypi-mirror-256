# coding: utf-8

"""
    XI Sdk Resellers

    For Resellers. Who are looking to Innovate with Ingram Micro's API SolutionsAutomate your eCommerce with our offering of APIs and Webhooks to create a seamless experience for your customers.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from xi.sdk.resellers.models.order_create_request_ordercreaterequest_ordercreatedetails_lines_inner_enduser import OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInnerEnduser
from xi.sdk.resellers.models.order_create_request_ordercreaterequest_ordercreatedetails_lines_inner_productextendedspecs_inner import OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInnerProductextendedspecsInner
from typing import Optional, Set
from typing_extensions import Self

class OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInner(BaseModel):
    """
    OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInner
    """ # noqa: E501
    linetype: Optional[StrictStr] = Field(default=None, description="Values are “P” for product or “C” for comments. This can be left blank when ordering product and a “P” will be assumed.  If you are adding a COMMENT, then this value must be “C”.  Extended spec for comments:   Attribute Name: “commenttext” Attribute Value: “thank you for the order”  To make the comment invisible to the packing slip place “///” in front of the comment in the Attribute Value field.  This will allow the Ingram sales rep to see the comment on the order but will not forward on to shipping documents.")
    linenumber: Optional[StrictStr] = Field(default=None, description="This is used when a partner wants to use their own line number. Can be left blank.")
    ingrampartnumber: Optional[StrictStr] = Field(default=None, description="This is the Ingram sku number to be used for placing an order.")
    quantity: StrictStr = Field(description="The quantity that is to be ordered.")
    vendorpartnumber: Optional[StrictStr] = Field(default=None, description="The Manufacturer part number. Can be used to place an order instead of the Ingram sku.  If there are multiple Ingram part numbers to one vendor part number.  The order will be rejected.")
    customerpartnumber: Optional[StrictStr] = Field(default=None, description="This is the Customers unique part numbers that must be crossed referenced to the Ingram Micro Sku before it can be used.  Please contact your sales rep for additional information on how to set this up.")
    upc_code: Optional[StrictStr] = Field(default=None, alias="UPCCode")
    warehouseid: Optional[StrictStr] = None
    unitprice: Optional[StrictStr] = Field(default=None, description="This is a requested price from the customer. Pre-approval is necessary before using this feature.  A methodology called price variance to manage requested pricing needs to be setup in advance by your sales rep.  If unit price is provided without this advanced setup the unit price will be ignored and standard Ingram Micro pricing will apply.")
    enduser: Optional[OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInnerEnduser] = None
    productextendedspecs: Optional[List[OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInnerProductextendedspecsInner]] = None
    __properties: ClassVar[List[str]] = ["linetype", "linenumber", "ingrampartnumber", "quantity", "vendorpartnumber", "customerpartnumber", "UPCCode", "warehouseid", "unitprice", "enduser", "productextendedspecs"]

    @field_validator('linetype')
    def linetype_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['P', 'C']):
            raise ValueError("must be one of enum values ('P', 'C')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of enduser
        if self.enduser:
            _dict['enduser'] = self.enduser.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in productextendedspecs (list)
        _items = []
        if self.productextendedspecs:
            for _item in self.productextendedspecs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['productextendedspecs'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "linetype": obj.get("linetype"),
            "linenumber": obj.get("linenumber"),
            "ingrampartnumber": obj.get("ingrampartnumber"),
            "quantity": obj.get("quantity"),
            "vendorpartnumber": obj.get("vendorpartnumber"),
            "customerpartnumber": obj.get("customerpartnumber"),
            "UPCCode": obj.get("UPCCode"),
            "warehouseid": obj.get("warehouseid"),
            "unitprice": obj.get("unitprice"),
            "enduser": OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInnerEnduser.from_dict(obj["enduser"]) if obj.get("enduser") is not None else None,
            "productextendedspecs": [OrderCreateRequestOrdercreaterequestOrdercreatedetailsLinesInnerProductextendedspecsInner.from_dict(_item) for _item in obj["productextendedspecs"]] if obj.get("productextendedspecs") is not None else None
        })
        return _obj


