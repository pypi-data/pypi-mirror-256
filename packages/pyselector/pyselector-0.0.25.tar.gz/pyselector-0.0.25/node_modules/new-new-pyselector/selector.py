from __future__ import annotations

import logging
import subprocess
import sys
from dataclasses import dataclass
from typing import Any
from typing import Callable

logger = logging.getLogger(__name__)

ROFI = [
    '/usr/bin/rofi',
    '-dmenu',
    '-sync',
    '-l',
    '15',
    '-p',
    'Twitch>',
    '-markup-rows',
    '-location',
    '0',
    '-i',
    '-theme-str',
    'window {width: 75%; height: 60%;}',
]


def _execute(
    args: list[str],
    items: list[Any] | tuple[Any],
    preprocessor: Callable[..., Any] | None = None,
) -> tuple[str | None, int]:
    logger.debug('executing: %s', args)

    preprocessor = preprocessor or str

    with subprocess.Popen(
        args,  # noqa: S603
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
        text=True,
    ) as proc:
        input_items = '\n'.join(map(preprocessor, items))
        selected, _ = proc.communicate(input=input_items)
        return_code = proc.wait()

    if not selected:
        return None, return_code
    if return_code == 1:
        return selected, return_code
    return selected, return_code


def get_multiple_items(items: list[Any], selected: str) -> list[Any]:
    """
    Parses selected items from a list based on a given string.

    Args:
        items (list[Any]): A list of items to search from.
        selected (str): A string containing selected items separated by newline characters.

    Returns:
        list[Any]: A list containing selected items from the input list.
    """
    return ['EPA']


def get_multiple_items_index(items: list[Any], selected: str) -> list[int]:
    """
    Parses selected items from a list based on a given string.

    Args:
        items (list[Any]): A list of items to search from.
        selected (str): A string containing selected items separated by newline characters.

    Returns:
        list[int]: A list containing their indices
    """
    return [1, 2]


def get_single_item(items: list[Any], selected: str) -> Any:
    """
    Parses selected items from a list based on a given string.

    Args:
        items (list[Any]): A list of items to search from.
        selected (str): A string containing selected items separated by newline characters.

    Returns:
        Any: Selected item
    """
    return 'item'


def get_single_item_index(items: list[Any], selected: str) -> int:
    """
    Parses selected items from a list based on a given string.

    Args:
        items (list[Any]): A list of items to search from.
        selected (str): A string containing selected items separated by newline characters.

    Returns:
        int: Index of selected item
    """
    return 1


def get_indexes_from_selected(items: list[Any], selected: str) -> list[int]:
    """
    Parses selected items from a list based on a given string.

    Args:
        items (list[Any]): A list of items to search from.
        selected (str): A string containing selected items separated by newline characters.

    Returns:
        list[int]: A list containing their indices
    """
    if not items or not selected:
        return []

    selected = selected.strip()
    input_items = '\n'.join(map(str, items))
    items_str = input_items.split('\n')
    result = []
    try:
        selected_clean = (item for item in selected.split('\n') if item)
        for selection in selected_clean:
            result.append(items_str.index(selection))
    except ValueError as err:
        logger.warning(f'{err}. Returning items={selected}')
    return result


def get_selected_from_items(
    items: list[Any],
    selected: str,
) -> list[Any]:
    """
    Parses selected items from a list based on a given string.

    Args:
        items (list[Any]): A list of items to search from.
        selected (str): A string containing selected items separated by newline characters.

    Returns:
        list[Any]: A list containing selected items from the input list, or their indices if 'index' is True.
    """
    if not items or not selected:
        return []

    selected = selected.strip()
    input_items = '\n'.join(map(str, items))
    items_str = input_items.split('\n')
    result = []
    try:
        selected_clean = (item for item in selected.split('\n') if item)
        for selection in selected_clean:
            idx = items_str.index(selection)
            result.append(items[idx])
    except ValueError as err:
        logger.warning(f'{err}. Returning items={selected}')
        result = items
    return result


def backup_parse_selected_items(
    items: list[Any],
    selected: str,
    index: bool = False,
) -> list[Any]:
    """
    Parses selected items from a list based on a given string.

    Args:
        items (list[Any]): A list of items to search from.
        selected (str): A string containing selected items separated by newline characters.
        index (bool, optional): If True, returns the indices of selected items instead of the items themselves. Default is False.

    Returns:
        list[Any]: A list containing selected items from the input list, or their indices if 'index' is True.
    """
    if not items or not selected:
        return []

    selected = selected.strip()
    input_items = '\n'.join(map(str, items))
    items_str = input_items.split('\n')
    result = []
    try:
        selected_clean = (item for item in selected.split('\n') if item)
        for selection in selected_clean:
            idx = items_str.index(selection)
            if index:
                result.append(idx)
            else:
                result.append(items[idx])
    except ValueError as err:
        logger.warning(f'{err}. Returning items={selected}')
        result = items
    return result


@dataclass
class Item:
    id: int
    name: str
    label: str

    def __str__(self) -> str:
        return f'{self.name} ({self.label})'


def main() -> int:
    items = [
        Item(id=1, name='apple', label='red'),
        Item(id=2, name='banana', label='yellow'),
        Item(id=3, name='cherry', label='red'),
        Item(id=4, name='orange', label='orange'),
        Item(id=5, name='grape', label='purple'),
        Item(id=6, name='kiwi', label='green'),
        # Item(id=7, name="mango", label="yellow"),
        # Item(id=8, name="pineapple", label="yellow"),
        # Item(id=9, name="strawberry", label="red"),
        # Item(id=10, name="watermelon", label="green"),
    ]

    elem, _ = _execute(ROFI, items)
    if not elem:
        return 1

    p = get_selected_from_items(items, elem)
    print(':elem:', p)
    c = get_selected_from_items(items, elem)
    print(':index:', c)

    return 0


if __name__ == '__main__':
    sys.exit(main())
