syntax = "proto3";

package deepmind.reverb;

import "tensorflow/core/protobuf/struct.proto";

message PatternNode {
  // Index of the source column in the flattened step structure.
  int32 flat_source_index = 1;

  // Slicing of the source column relative to the most recent step.
  //
  // These fields mimics the behavior of `slice` in Python. That is:
  //
  //  * x[-1:] => (start=-1, stop=null)
  //  * x[-2] => (start=null, stop=-2)
  //  * x[-3:-1] => (start=-3, stop=-1)
  //  * x[-3:-1:2] => (start=-3, stop=-1, step=2)
  //
  // Furthermore, the following requirements applies:
  //
  //  * Slices with undefined `start` (e.g. x[:-2]) are not supported.
  //  * For slices, `start` must be < 0 and `stop` must be <= 0.
  //  * `step` must be > 0 when defined.
  //
  oneof start_or_none {
    int32 start = 2;
  }
  oneof stop_or_none {
    int32 stop = 3;
  }
  oneof step_or_none {
    int32 step = 4;
  }
}

message Condition {
  // Given int32 `left`: `left % mod == eq`.
  message ModuloEq {
    int32 mod = 1;
    int32 eq = 2;
  }

  oneof left {
    // The index of the most recent step within the episode.
    bool step_index = 1;

    // The number of steps since the pattern was most recently applied.
    bool steps_since_applied = 2;

    // The number of steps currently held by the buffer.
    bool buffer_length = 3;

    // Set to 1 when `EndEpisode` is called, else 0.
    bool is_end_episode = 4;

    // Extract scalar integer value from a column in the most recent step. If
    // the column is not present in the data or it isn't a scalar of a supported
    // type then the condition will return false.
    //
    // All integer types are casted to int32 and bool is converted to 1 if true
    // and 0 if false.
    //
    int32 flat_source_index = 9;
  }

  // TODO(b/205278205): Remove le and just use inverse + ge instead.
  oneof cmp {
    // `left == eq`.
    int32 eq = 5;

    // `left >= ge`.
    int32 ge = 6;

    // `left % mod_eq.mod == mod_eq.eq`.
    ModuloEq mod_eq = 7;
  }

  // Whether the condition result should be inversed.
  bool inverse = 8;
}

message Priority {
  // Priority function that always return the same value.
  message ConstantPriorityFn {
    // Value to be returned by the priority function.
    double value = 1;
  }

  // Priority function that computes the trajectory TD Error using the per-step
  // TD Error. See details of the TD Error in
  // https://openreview.net/pdf?id=r1lyTjAqYX.
  message TDError {
    // Weight for the max priority in the TD Error computation.
    double max_priority_weight = 1;
    // Index of the field in the input step that contais the per-step TD Error.
    int32 flat_source_index = 2;
  }

  oneof priority_fn {
    ConstantPriorityFn constant_fn = 1;
    TDError td_error = 2;
  }
}

message StructuredWriterConfig {
  // Flattened output structure.
  repeated PatternNode flat = 1;

  // Serialised structure of the pattern. All leaf nodes must be None. If empty
  // then pattern will be treated as a flat list.
  tensorflow.StructuredValue pattern_structure = 2;

  // The table that generated trajectories will be inserted into.
  string table = 3;

  // The priority assigned to all trajectories generated by this config.
  Priority priority = 4;

  // Conditions which must be fulfilled for the configuration to be applied at
  // the current step.
  repeated Condition conditions = 5;
}
