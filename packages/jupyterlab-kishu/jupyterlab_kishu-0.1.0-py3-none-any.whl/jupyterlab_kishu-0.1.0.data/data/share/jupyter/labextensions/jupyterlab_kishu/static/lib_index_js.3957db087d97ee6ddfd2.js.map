{"version":3,"file":"lib_index_js.3957db087d97ee6ddfd2.js","mappings":"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","sources":["webpack://jupyterlab_kishu/./src/handler.ts","webpack://jupyterlab_kishu/./src/index.ts"],"sourcesContent":["import { URLExt } from '@jupyterlab/coreutils';\n\nimport { ServerConnection } from '@jupyterlab/services';\n\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI<T>(\n  endPoint = '',\n  init: RequestInit = {}\n): Promise<T> {\n  // Make request to Jupyter API\n  const settings = ServerConnection.makeSettings();\n  const requestUrl = URLExt.join(\n    settings.baseUrl,\n    'kishu', // API Namespace\n    endPoint\n  );\n\n  let response: Response;\n  try {\n    response = await ServerConnection.makeRequest(requestUrl, init, settings);\n  } catch (error) {\n    throw new ServerConnection.NetworkError(error as TypeError);\n  }\n  const data: string = await response.text();\n  if (!response.ok) {\n    throw new ServerConnection.ResponseError(response, data);\n  }\n  if (data.length > 0) {\n    try {\n      return JSON.parse(data);\n    } catch (error) {\n      console.log('Not a JSON response body.', response);\n    }\n  }\n  throw new ServerConnection.ResponseError(response, data);\n}\n","import {\n  JupyterFrontEnd,\n  JupyterFrontEndPlugin\n} from '@jupyterlab/application';\nimport {\n  ICommandPalette,\n  InputDialog,\n  Notification,\n} from '@jupyterlab/apputils';\nimport {\n  INotebookTracker,\n} from '@jupyterlab/notebook';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { ITranslator } from '@jupyterlab/translation';\n\nimport { requestAPI } from './handler';\n\nconst PLUGIN_ID = 'jupyterlab_kishu:plugin';\n\nnamespace CommandIDs {\n  /**\n   * Initialize Kishu on the currently viewed notebook.\n   */\n  export const init = 'kishu:init';\n\n  /**\n   * Checkout a commit on the currently viewed notebook.\n   */\n  export const checkout = 'kishu:checkout';\n\n  /**\n   * Create a commit on the currently viewed notebook.\n   */\n  export const commit = 'kishu:commit';\n}\n\nnamespace KishuSetting {\n  export let kishu_dir = \"\";\n}\n\ninterface CommitSummary {\n  commit_id: string;\n  parent_id: string;\n  message: string;\n  timestamp: string;\n  code_block?: string;\n  runtime_ms?: number;\n}\n\ninterface HeadBranch {\n  branch_name?: string;\n  commit_id?: string;\n}\n\ninterface InitResult {\n  status: string;\n  message: string;\n}\n\ninterface LogAllResult {\n  commit_graph: CommitSummary[];\n  head: HeadBranch;\n}\n\ninterface CheckoutResult {\n  status: string;\n  message: string;\n}\n\ninterface InstrumentResult {\n  status: string;\n  message?: string;\n}\n\ninterface CommitResult {\n  status: string;\n  message: string;\n  reattachment: InstrumentResult;\n}\n\nfunction notifyError(message: string) {\n  Notification.error(message, { autoClose: 3000 });\n}\n\nfunction currentNotebookPath(tracker: INotebookTracker): string | undefined {\n  const widget = tracker.currentWidget;\n  if (!widget) {\n    console.log(`Missing tracker widget to detect currently viewed notebook.`);\n    return undefined;\n  }\n  return widget.context.localPath;\n}\n\nfunction commitSummaryToString(commit: CommitSummary): string {\n  const date = new Date(commit.timestamp);\n  return `[${date.toLocaleString()}]: ${commit.message} (${commit.commit_id})`;\n}\n\nfunction extractHashFromString(inputString: string): string | undefined {\n  const regex = /\\(([0-9a-fA-F-]+)\\)$/;\n  const match = inputString.match(regex);\n  if (match && match[1]) {\n    return match[1];\n  }\n  return undefined;\n}\n\nfunction loadSetting(setting: ISettingRegistry.ISettings): void {\n  // Read the settings and convert to the correct type\n  KishuSetting.kishu_dir = setting.get('kishu_dir').composite as string;\n  console.log(`Settings: kishu_dir= ${KishuSetting.kishu_dir}`);\n}\n\nfunction installCommands(\n  app: JupyterFrontEnd,\n  palette: ICommandPalette,\n  translator: ITranslator,\n  tracker: INotebookTracker,\n) {\n  const { commands } = app;\n  const trans = translator.load('jupyterlab');\n\n  /**\n   * Init\n   */\n\n  commands.addCommand(CommandIDs.init, {\n    label: trans.__('Kishu: Initialize/Re-attach'),\n    execute: async (_args) => {\n      // Detect currently viewed notebook.\n      const notebook_path = currentNotebookPath(tracker);\n      if (!notebook_path) {\n        notifyError(trans.__(`No currently viewed notebook detected to initialize/attach.`));\n        return;\n      }\n\n      // Make init request\n      const init_promise = requestAPI<InitResult>('init', {\n        method: 'POST',\n        body: JSON.stringify({notebook_path: notebook_path}),\n      });\n\n      // Report.\n      const notify_manager = Notification.manager;\n      const notify_id = notify_manager.notify(\n        trans.__(`Initializing Kishu on ${notebook_path}...`),\n        'in-progress',\n        { autoClose: false },\n      );\n      init_promise.then((init_result,) => {\n        if (init_result.status != \"ok\") {\n          notify_manager.update({\n            id: notify_id,\n            message: trans.__(`Kishu init failed.\\n\"${init_result.message}\"`),\n            type: 'error',\n            autoClose: 3000,\n          });\n        } else {\n          notify_manager.update({\n            id: notify_id,\n            message: trans.__(`Kishu init succeeded!\\n\"${init_result.message}\"`),\n            type: 'success',\n            autoClose: 3000,\n          });\n        }\n      });\n    }\n  });\n  palette.addItem({\n    command: CommandIDs.init,\n    category: 'Kishu',\n  });\n\n  /**\n   * Checkout\n   */\n\n  commands.addCommand(CommandIDs.checkout, {\n    label: trans.__('Kishu: Checkout...'),\n    execute: async (_args) => {\n      // Detect currently viewed notebook.\n      const notebook_path = currentNotebookPath(tracker);\n      if (!notebook_path) {\n        notifyError(trans.__(`No currently viewed notebook detected to checkout.`));\n        return;\n      }\n\n      // List all commits.\n      const log_all_result = await requestAPI<LogAllResult>('log_all', {\n        method: 'POST',\n        body: JSON.stringify({notebook_path: notebook_path}),\n      });\n\n      // Ask for the target commit ID.\n      let maybe_commit_id = undefined;\n      if (!log_all_result || log_all_result.commit_graph.length == 0) {\n        // Failed to list, asking in text dialog directly.\n        maybe_commit_id = (\n          await InputDialog.getText({\n            placeholder: '<commit_id>',\n            title: trans.__('Checkout to...'),\n            okLabel: trans.__('Checkout')\n          })\n        ).value ?? undefined;\n        if (!maybe_commit_id) {\n          notifyError(trans.__(`Kishu checkout requires commit ID.`));\n        }\n      } else {\n        // Find the index to current commit.\n        let current_idx = log_all_result.commit_graph.findIndex(\n          commit => commit.commit_id === log_all_result.head.commit_id\n        );\n        if (current_idx == -1) {\n          current_idx = log_all_result.commit_graph.length - 1;\n        }\n\n        // Show the list and ask to pick one item\n        const selected_commit_str = (\n          await InputDialog.getItem({\n            items: log_all_result.commit_graph.map(commitSummaryToString),\n            current: current_idx,\n            editable: false,\n            title: trans.__('Checkout to...'),\n            okLabel: trans.__('Checkout')\n          })\n        ).value ?? undefined;\n        if (selected_commit_str !== undefined) {\n          maybe_commit_id = extractHashFromString(selected_commit_str);\n        }\n      }\n      if (!maybe_commit_id) {\n        return;\n      }\n      const commit_id: string = maybe_commit_id;\n\n      // Make checkout request\n      const checkout_promise = requestAPI<CheckoutResult>('checkout', {\n        method: 'POST',\n        body: JSON.stringify({notebook_path: notebook_path, commit_id: commit_id}),\n      });\n\n      // Reports.\n      const notify_manager = Notification.manager;\n      const notify_id = notify_manager.notify(\n        trans.__(`Checking out ${commit_id}...`),\n        'in-progress',\n        { autoClose: false },\n      );\n      checkout_promise.then((checkout_result,) => {\n        if (checkout_result.status != \"ok\") {\n          notify_manager.update({\n            id: notify_id,\n            message: trans.__(`Kishu checkout failed.\\n\"${checkout_result.message}\"`),\n            type: 'error',\n            autoClose: 3000,\n          });\n        } else {\n          notify_manager.update({\n            id: notify_id,\n            message: trans.__(`Kishu checkout to ${commit_id} succeeded!`),\n            type: 'success',\n            autoClose: 3000,\n          });\n        }\n      });\n    }\n  });\n  palette.addItem({\n    command: CommandIDs.checkout,\n    category: 'Kishu',\n  });\n\n  /**\n   * Commit\n   */\n\n  commands.addCommand(CommandIDs.commit, {\n    label: trans.__('Kishu: Commit...'),\n    execute: async (_args) => {\n      // Detect currently viewed notebook.\n      const notebook_path = currentNotebookPath(tracker);\n      if (!notebook_path) {\n        notifyError(trans.__(`No currently viewed notebook detected to ommit.`));\n        return;\n      }\n\n      // Ask for the commit message.\n      const message = (\n        await InputDialog.getText({\n          placeholder: '<commit_message>',\n          title: trans.__('Commit message'),\n          okLabel: trans.__('Commit')\n        })\n      ).value ?? undefined;\n      if (!message) {\n        notifyError(trans.__(`Kishu commit requires a commit message.`));\n      }\n\n      // Make checkout request\n      const commit_promise = requestAPI<CommitResult>('commit', {\n        method: 'POST',\n        body: JSON.stringify({notebook_path: notebook_path, message: message}),\n      });\n\n      // Reports.\n      const notify_manager = Notification.manager;\n      const notify_id = notify_manager.notify(\n        trans.__(`Creating a commit...`),\n        'in-progress',\n        { autoClose: false },\n      );\n      commit_promise.then((commit_result,) => {\n        if (commit_result.status != \"ok\") {\n          notify_manager.update({\n            id: notify_id,\n            message: trans.__(`Kishu commit failed.\\n\"${commit_result.message}\"`),\n            type: 'error',\n            autoClose: 3000,\n          });\n        } else {\n          notify_manager.update({\n            id: notify_id,\n            message: trans.__(`Kishu commit succeeded!`),\n            type: 'success',\n            autoClose: 3000,\n          });\n        }\n      });\n    }\n  });\n  palette.addItem({\n    command: CommandIDs.commit,\n    category: 'Kishu',\n  });\n}\n\n/**\n * Initialization data for the jupyterlab_kishu extension.\n */\nconst plugin: JupyterFrontEndPlugin<void> = {\n  id: PLUGIN_ID,\n  description: 'Jupyter extension to interact with Kishu',\n  autoStart: true,\n  requires: [ICommandPalette, ITranslator, ISettingRegistry, INotebookTracker],\n  activate: (\n    app: JupyterFrontEnd,\n    palette: ICommandPalette,\n    translator: ITranslator,\n    settings: ISettingRegistry,\n    tracker: INotebookTracker,\n  ) => {\n    Promise.all([app.restored, settings.load(PLUGIN_ID)])\n      .then(([, setting]) => {\n        // Setting registry.\n        loadSetting(setting);\n        setting.changed.connect(loadSetting);\n\n        // Install commands.\n        installCommands(app, palette, translator, tracker);\n      })\n      .catch(reason => {\n        console.error(\n          `Something went wrong when reading the settings.\\n${reason}`\n        );\n      });\n  }\n};\n\nexport default plugin;\n"],"names":[],"sourceRoot":""}